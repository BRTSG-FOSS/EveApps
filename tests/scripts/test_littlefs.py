#!/usr/bin/env python3

# Copyright (c) 2022, The littlefs authors.
# Copyright (c) 2017, Arm Limited. All rights reserved.
# 
# This file has been modified by the following contributers:
# Copyright (c) 2022, Bridgetek Pte Ltd.
# 
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
# 
# -  Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
# -  Redistributions in binary form must reproduce the above copyright notice, this
#    list of conditions and the following disclaimer in the documentation and/or
#    other materials provided with the distribution.
# -  Neither the name of ARM nor the names of its contributors may be used to
#    endorse or promote products derived from this software without specific prior
#    written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# 

# This script manages littlefs tests, which are configured with
# .toml files stored in the tests directory.
#

import toml
import glob
import re
import os
import io
import itertools as it
import collections.abc as abc
import subprocess as sp
import base64
import sys
import copy
import shlex
# import pty
import errno
import signal

TEST_PATHS = '../../dependencies/littlefs/tests'
SRC_PATHS = '../../dependencies/littlefs'
RULES = """
# add block devices to sources
TESTSRC ?= $(SRC) $(wildcard ../../dependencies/littlefs/bd/*.c)

define FLATTEN
%(path)s%%$(subst /,.,$(target)): $(target)
    ../../dependencies/littlefs/scripts/explode_asserts.py $$< -o $$@
endef
$(foreach target,$(TESTSRC),$(eval $(FLATTEN)))

-include %(path)s*.d
.SECONDARY:

%(path)s.test: %(path)s.test.o \\
        $(foreach t,$(subst /,.,$(TESTSRC:.c=.o)),%(path)s.$t)
    $(CC) $(CFLAGS) $^ $(LFLAGS) -o $@

# needed in case builddir is different
%(path)s%%.o: %(path)s%%.c
    $(CC) -c -MMD $(CFLAGS) $< -o $@
"""
COVERAGE_RULES = """
%(path)s.test: override CFLAGS += -fprofile-arcs -ftest-coverage

# delete lingering coverage
%(path)s.test: | %(path)s.info.clean
.PHONY: %(path)s.info.clean
%(path)s.info.clean:
    rm -f %(path)s*.gcda

# accumulate coverage info
.PHONY: %(path)s.info
%(path)s.info:
    $(strip $(LCOV) -c \\
        $(addprefix -d ,$(wildcard %(path)s*.gcda)) \\
        --rc 'geninfo_adjust_src_path=$(shell pwd)' \\
        -o $@)
    $(LCOV) -e $@ $(addprefix /,$(SRC)) -o $@
ifdef COVERAGETARGET
    $(strip $(LCOV) -a $@ \\
        $(addprefix -a ,$(wildcard $(COVERAGETARGET))) \\
        -o $(COVERAGETARGET))
endif
"""
GLOBALS = """
//////////////// AUTOGENERATED TEST ////////////////
#include "lfs.h"
#include "bd/lfs_testbd.h"
#include <stdio.h>
extern const char *lfs_testbd_path;
extern uint32_t lfs_testbd_cycles;
"""
GLOBALS_EVE = """
//////////////// AUTOGENERATED TEST ////////////////
#include <Esd_Core.h>
#include <Esd_LittleFS.h>
#include "lfs.h"
#include "bd/lfs_testbd.h"
#include <stdio.h>
extern const char *lfs_testbd_path;
extern uint32_t lfs_testbd_cycles;
"""
DEFINES = {
    'LFS_READ_SIZE': 16,
    'LFS_PROG_SIZE': 'LFS_READ_SIZE',
    'LFS_BLOCK_SIZE': 512,
    'LFS_BLOCK_COUNT': 1024,
    'LFS_BLOCK_CYCLES': -1,
    'LFS_CACHE_SIZE': '(64 % LFS_PROG_SIZE == 0 ? 64 : LFS_PROG_SIZE)',
    'LFS_LOOKAHEAD_SIZE': 16,
    'LFS_ERASE_VALUE': 0xff,
    'LFS_ERASE_CYCLES': 0,
    'LFS_BADBLOCK_BEHAVIOR': 'LFS_TESTBD_BADBLOCK_PROGERROR',
}
DEFINES_EVE = {
    'LFS_READ_SIZE': 64,
    'LFS_PROG_SIZE': 256,
    'LFS_BLOCK_SIZE': 4096,
    'LFS_BLOCK_COUNT': '(EVE_FLASH_SIZE * (1024 * 1024 / 4096) - 1)',
    'LFS_BLOCK_CYCLES': -1,
    'LFS_CACHE_SIZE': 'LFS_PROG_SIZE',
    'LFS_LOOKAHEAD_SIZE': 32,
    'LFS_ERASE_VALUE': 0xff,
    'LFS_ERASE_CYCLES': 0,
    'LFS_BADBLOCK_BEHAVIOR': 'LFS_TESTBD_BADBLOCK_PROGERROR',
}
PROLOGUE = """
    // prologue
    __attribute__((unused)) lfs_t lfs;
    __attribute__((unused)) lfs_testbd_t bd;
    __attribute__((unused)) lfs_file_t file;
    __attribute__((unused)) lfs_dir_t dir;
    __attribute__((unused)) struct lfs_info info;
    __attribute__((unused)) char path[1024];
    __attribute__((unused)) uint8_t buffer[LFS_BLOCK_SIZE * 4];
    __attribute__((unused)) lfs_size_t size;
    __attribute__((unused)) int err;
    
    __attribute__((unused)) const struct lfs_config cfg = {
        .context        = &bd,
        .read           = lfs_testbd_read,
        .prog           = lfs_testbd_prog,
        .erase          = lfs_testbd_erase,
        .sync           = lfs_testbd_sync,
        .read_size      = LFS_READ_SIZE,
        .prog_size      = LFS_PROG_SIZE,
        .block_size     = LFS_BLOCK_SIZE,
        .block_count    = LFS_BLOCK_COUNT,
        .block_cycles   = LFS_BLOCK_CYCLES,
        .cache_size     = LFS_CACHE_SIZE,
        .lookahead_size = LFS_LOOKAHEAD_SIZE,
    };

    __attribute__((unused)) const struct lfs_testbd_config bdcfg = {
        .erase_value        = LFS_ERASE_VALUE,
        .erase_cycles       = LFS_ERASE_CYCLES,
        .badblock_behavior  = LFS_BADBLOCK_BEHAVIOR,
        .power_cycles       = lfs_testbd_cycles,
    };

    lfs_testbd_createcfg(&cfg, lfs_testbd_path, &bdcfg) => 0;
"""
PROLOGUE_EVE = """
    // prologue
    __attribute__((unused)) lfs_t lfs;
    __attribute__((unused)) lfs_file_t file;
    __attribute__((unused)) lfs_dir_t dir;
    __attribute__((unused)) struct lfs_info info;
    __attribute__((unused)) char path[1024];
    __attribute__((unused)) uint8_t buffer[LFS_BLOCK_SIZE * 4];
    __attribute__((unused)) lfs_size_t size;
    __attribute__((unused)) int err;
    __attribute__((unused)) struct lfs_config cfg;
    __attribute__((unused)) Esd_Context esdcontext;
    __attribute__((unused)) Esd_Context *ec = &esdcontext;
    __attribute__((unused)) EVE_HalContext *phost = &esdcontext.HalContext;
    if (LFS_ERASE_VALUE != 0xFF)
    {
        eve_printf("Erase value not applicable, don't run test\\n");
        return;
    }
    if (LFS_ERASE_CYCLES)
    {
        eve_printf("Erase cycle tests are not applicable, don't run test\\n");
        return;
    }
    Esd_Initialize();
    {
        Esd_Parameters ep;
        Esd_Defaults(&ep);
#ifdef ESD_FLASH_FILES
        wcscpy_s(ep.FlashFilePaths[ESD_FLASH_BT815], _countof(ep.FlashFilePaths[ESD_FLASH_BT815]), L"..\\\\..\\\\common\\\\eve_flash\\\\BT815-unified.blob");
#if (EVE_SUPPORT_CHIPID >= EVE_BT817)
        wcscpy_s(ep.FlashFilePaths[ESD_FLASH_BT817], _countof(ep.FlashFilePaths[ESD_FLASH_BT817]), L"..\\\\..\\\\common\\\\eve_flash\\\\BT817-unified.blob");
#endif
#endif
        Esd_Open(ec, &ep) => true;
        Esd_SetCurrent(ec);
        Esd_Start(ec);
        Esd_LittleFS_Mount(ec);
        Esd_LittleFS_Unmount(ec);
        cfg = ec->LfsConfig;
        LFS_ASSERT(cfg.block_size >= LFS_BLOCK_SIZE);
        cfg.block_size = LFS_BLOCK_SIZE;
        LFS_ASSERT(cfg.block_count >= LFS_BLOCK_COUNT);
        cfg.block_count = LFS_BLOCK_COUNT;
        cfg.block_cycles = LFS_BLOCK_CYCLES;
        if (sizeof(ec->LfsReadBuffer) < LFS_CACHE_SIZE
            || sizeof(ec->LfsProgBuffer) < LFS_CACHE_SIZE)
        {
            cfg.read_buffer = NULL;
            cfg.prog_buffer = NULL;
        }
        cfg.cache_size = LFS_CACHE_SIZE;
        if (sizeof(ec->LfsLookaheadBuffer) < LFS_LOOKAHEAD_SIZE)
        {
            cfg.lookahead_buffer = NULL;
        }
        cfg.lookahead_size = LFS_LOOKAHEAD_SIZE;
    }
    {
        int chipId = EVE_CHIPID;
        char deviceName[64] = "Bridgetek BT8XX";
        char *chipPrefix = (EVE_GEN >= EVE3 || chipId >= EVE_BT880) ? "BT" : "FT";
        char *chipBranding = (EVE_GEN >= EVE3 || chipId >= EVE_BT880) ? "Bridgetek" : "FTDI";
        sprintf(deviceName, "%s %s%lx", chipBranding, chipPrefix, (unsigned long)EVE_shortChipId(chipId));
        // EVE_Hal_wr32(phost, REG_MACRO_0, BITMAP_TRANSFORM_F(256));
        EVE_CoCmd_memZero(phost, 0, 4096 * 2);
        // EVE_CoCmd_memSet(phost, 0, 0xFF, LFS_BLOCK_SIZE * 2);
        EVE_CoCmd_dlStart(phost);
        EVE_CoDl_clearColorRgb(phost, 0, 0, 0);
        EVE_CoDl_clear(phost, 1, 1, 1);
        EVE_CoDl_blendFunc(phost, SRC_ALPHA, ONE);
        EVE_CoDl_colorRgb(phost, 64, 192, 64);
        EVE_CoDl_bitmapHandle(phost, 0);
        EVE_CoCmd_setBitmap(phost, 0, TEXT8X8, 512, 512);
        EVE_CoCmd_dl(phost, BITMAP_SIZE_H(2, 4));
        EVE_CoCmd_dl(phost, BITMAP_SIZE(NEAREST, REPEAT, REPEAT, 0, 0));
        EVE_CoDl_bitmapHandle(phost, 1);
        EVE_CoCmd_setBitmap(phost, 4096, TEXT8X8, 512, 512);
        EVE_CoCmd_dl(phost, BITMAP_SIZE_H(2, 4));
        EVE_CoCmd_dl(phost, BITMAP_SIZE(NEAREST, REPEAT, REPEAT, 0, 0));
        EVE_CoDl_begin(phost, BITMAPS);
        // EVE_CoDl_macro(phost, 0);
        EVE_CoDl_vertex2ii(phost, 0, 0, 0, 0);
        EVE_CoDl_vertex2ii(phost, 0, 0, 1, 0);
        EVE_CoDl_end(phost);
        EVE_CoDl_blendFunc_default(phost);
        // EVE_CoCmd_dl(phost, BITMAP_TRANSFORM_F(0));
        EVE_CoDl_colorRgb(phost, 255, 255, 255);
        EVE_CoCmd_text(phost, 5, 5, 30, 0, deviceName);
        EVE_CoCmd_text(phost, 5, 45, 28, 0, "EVE LittleFS Tests");
        // EVE_CoDl_macro(phost, 0);
        // EVE_CoDl_begin(phost, POINTS);
        // EVE_CoDl_pointSize(phost, 180);
        // EVE_CoDl_vertexFormat(phost, 1);
        // EVE_CoDl_vertex2f(phost, 45, 45);
        // EVE_CoDl_end(phost);
        EVE_CoDl_display(phost);
        EVE_CoCmd_swap(phost);
        EVE_Hal_flush(phost);
    }
    if (!lfs_testbd_path || !strcmp(lfs_testbd_path, "test_littlefs.disk.erase"))
    {
        EVE_CoCmd_memSet(phost, 0, 0xFF, LFS_BLOCK_SIZE * 2);
        EVE_CoCmd_flashUpdate(phost, 4096, 0, LFS_BLOCK_SIZE * 2);
        EVE_Cmd_waitFlush(phost) => true;
    }
"""
EPILOGUE = """
    // epilogue
    lfs_testbd_destroy(&cfg) => 0;
"""
EPILOGUE_EVE = """
    // epilogue
    if (!lfs_testbd_path)
    {
        EVE_CoCmd_memSet(phost, 0, 0xFF, LFS_BLOCK_SIZE * 2);
        EVE_CoCmd_flashUpdate(phost, 4096, 0, LFS_BLOCK_SIZE * 2);
        EVE_Cmd_waitFlush(phost) => true;
    }
    Esd_Stop(ec);
    Esd_Close(ec);
    Esd_Release();
"""
PASS = 'p'
FAIL = 'F'
SKIP = 's'

class TestFailure(Exception):
    def __init__(self, case, returncode=None, stdout=None, assert_=None):
        self.case = case
        self.returncode = returncode
        self.stdout = stdout
        self.assert_ = assert_

class TestCase:
    def __init__(self, config, filter=filter,
            suite=None, caseno=None, lineno=None, **_):
        self.config = config
        self.filter = filter
        self.suite = suite
        self.caseno = caseno
        self.lineno = lineno

        self.code = config['code']
        self.code_lineno = config['code_lineno']
        self.defines = config.get('define', {})
        self.if_ = config.get('if', None)
        self.in_ = config.get('in', None)

        self.result = None

    def __str__(self):
        if hasattr(self, 'permno'):
            if any(k not in self.case.defines for k in self.defines):
                return '%s#%d#%d (%s)' % (
                    self.suite.name, self.caseno, self.permno, ', '.join(
                        '%s=%s' % (k, v) for k, v in self.defines.items()
                        if k not in self.case.defines))
            else:
                return '%s#%d#%d' % (
                    self.suite.name, self.caseno, self.permno)
        else:
            return '%s#%d' % (
                self.suite.name, self.caseno)

    def permute(self, class_=None, defines={}, permno=None, **_):
        ncase = (class_ or type(self))(self.config)
        for k, v in self.__dict__.items():
            setattr(ncase, k, v)
        ncase.case = self
        ncase.perms = [ncase]
        ncase.permno = permno
        ncase.defines = defines
        return ncase

    def build(self, f, **_):
        # prologue
        for k, v in sorted(self.defines.items()):
            if k not in self.suite.defines:
                f.write('#define %s %s\n' % (k, v))

        f.write('void test_case%d(%s) {' % (self.caseno, ','.join(
            '\n'+8*' '+'__attribute__((unused)) intmax_t %s' % k
            for k in sorted(self.perms[0].defines)
            if k not in self.defines)))

        f.write(PROLOGUE)
        f.write('\n')
        f.write(4*' '+'// test case %d\n' % self.caseno)
        f.write(4*' '+'#line %d "%s"\n' % (self.code_lineno, self.suite.path))

        # test case goes here
        f.write(self.code)

        # epilogue
        f.write(EPILOGUE)
        f.write('}\n')

        for k, v in sorted(self.defines.items()):
            if k not in self.suite.defines:
                f.write('#undef %s\n' % k)

    def shouldtest(self, **args):
        if (self.filter is not None and
                len(self.filter) >= 1 and
                self.filter[0] != self.caseno):
            return False
        elif (self.filter is not None and
                len(self.filter) >= 2 and
                self.filter[1] != self.permno):
            return False
        elif args.get('no_internal') and self.in_ is not None:
            return False
        elif self.if_ is not None:
            if_ = self.if_
            while True:
                for k, v in sorted(self.defines.items(),
                        key=lambda x: len(x[0]), reverse=True):
                    if k in if_:
                        if_ = if_.replace(k, '(%s)' % v)
                        break
                else:
                    break
            if_ = (
                re.sub('(\&\&|\?)', ' and ',
                re.sub('(\|\||:)', ' or ',
                re.sub('!(?!=)', ' not ', if_))))
            return eval(if_)
        else:
            return True

    def test(self, exec=[], persist=False, cycles=None,
            gdb=False, failure=None, disk=None, **args):
        # build command
        cmd = exec + ['../../dependencies/littlefs/tests/bin/Debug/%s.exe' % self.suite.name,
            repr(self.caseno), repr(self.permno)]

        # persist disk or keep in RAM for speed?
        if persist:
            if not disk:
                disk = self.suite.path + '.disk'
            if persist != 'noerase':
                try:
                    with open(disk, 'w') as f:
                        f.truncate(0)
                    if args.get('verbose'):
                        print('truncate --size=0', disk)
                except FileNotFoundError:
                    pass
            if args.get('eve_platform') or args.get('eve_graphics'):
                if persist != 'noerase':
                    disk = 'test_littlefs.disk.erase'
                else:
                    disk = 'test_littlefs.disk.noerase'
            cmd.append(disk)

        # simulate power-loss after n cycles?
        if cycles:
            cmd.append(str(cycles))

        # failed? drop into debugger?
        if gdb and failure:
            ncmd = ['gdb']
            if gdb == 'assert':
                ncmd.extend(['-ex', 'r'])
                if failure.assert_:
                    ncmd.extend(['-ex', 'up 2'])
            elif gdb == 'main':
                ncmd.extend([
                    '-ex', 'b %s:%d' % (self.suite.path, self.code_lineno),
                    '-ex', 'r'])
            ncmd.extend(['--args'] + cmd)

            if args.get('verbose'):
                print(' '.join(shlex.quote(c) for c in ncmd))
            signal.signal(signal.SIGINT, signal.SIG_IGN)
            sys.exit(sp.call(ncmd))

        # run test case!
        returncode = 0
        output = ""
        anyerror = False
        try:
            output = sp.check_output(cmd, text=True)
        except sp.CalledProcessError as e:
            anyerror = True
            errorcode = e.returncode
            output = e.output
        except OSError as e:
            if e.errno != errno.EIO:
                raise
        except KeyboardInterrupt as e:
            raise TestFailure(self, 1, [], None)
        stdout = output.splitlines()
        assert_ = None
        rescode = PASS
        for idx, line in enumerate(stdout):
            if "not applicable, don't run test" in line:
                rescode = SKIP
            stdout[idx] = line + '\n'
        for line in stdout:
            if args.get('verbose'):
                sys.stdout.write(line)
            # intercept asserts
            m = re.match(
                '^{0}([^:]+):(\d+):(?:\d+:)?{0}{1}:{0}(.*)$'
                .format('(?:\033\[[\d;]*.| )*', 'assert'),
                line)
            if m and assert_ is None:
                try:
                    with open(m.group(1)) as f:
                        lineno = int(m.group(2))
                        line = (next(it.islice(f, lineno-1, None))
                            .strip('\n'))
                    assert_ = {
                        'path': m.group(1),
                        'line': line,
                        'lineno': lineno,
                        'message': m.group(3)}
                except:
                    pass
        if returncode != 0 or assert_ or anyerror:
            raise TestFailure(self, returncode, stdout, assert_)
        else:
            return rescode
        """
        mpty, spty = pty.openpty()
        if args.get('verbose'):
            print(' '.join(shlex.quote(c) for c in cmd))
        proc = sp.Popen(cmd, stdout=spty, stderr=spty)
        os.close(spty)
        mpty = os.fdopen(mpty, 'r', 1)
        stdout = []
        assert_ = None
        try:
            while True:
                try:
                    line = mpty.readline()
                except OSError as e:
                    if e.errno == errno.EIO:
                        break
                    raise
                if not line:
                    break;
                stdout.append(line)
                if args.get('verbose'):
                    sys.stdout.write(line)
                # intercept asserts
                m = re.match(
                    '^{0}([^:]+):(\d+):(?:\d+:)?{0}{1}:{0}(.*)$'
                    .format('(?:\033\[[\d;]*.| )*', 'assert'),
                    line)
                if m and assert_ is None:
                    try:
                        with open(m.group(1)) as f:
                            lineno = int(m.group(2))
                            line = (next(it.islice(f, lineno-1, None))
                                .strip('\n'))
                        assert_ = {
                            'path': m.group(1),
                            'line': line,
                            'lineno': lineno,
                            'message': m.group(3)}
                    except:
                        pass
        except KeyboardInterrupt:
            raise TestFailure(self, 1, stdout, None)
        proc.wait()

        # did we pass?
        if proc.returncode != 0:
            raise TestFailure(self, proc.returncode, stdout, assert_)
        else:
            return PASS
        """

class ValgrindTestCase(TestCase):
    def __init__(self, config, **args):
        self.leaky = config.get('leaky', False)
        super().__init__(config, **args)

    def shouldtest(self, **args):
        return not self.leaky and super().shouldtest(**args)

    def test(self, exec=[], **args):
        verbose = args.get('verbose')
        uninit = (self.defines.get('LFS_ERASE_VALUE', None) == -1)
        exec = [
            'valgrind',
            '--leak-check=full',
            ] + (['--undef-value-errors=no'] if uninit else []) + [
            ] + (['--track-origins=yes'] if not uninit else []) + [
            '--error-exitcode=4',
            '--error-limit=no',
            ] + (['--num-callers=1'] if not verbose else []) + [
            '-q'] + exec
        return super().test(exec=exec, **args)

class ReentrantTestCase(TestCase):
    def __init__(self, config, **args):
        self.reentrant = config.get('reentrant', False)
        super().__init__(config, **args)

    def shouldtest(self, **args):
        return self.reentrant and super().shouldtest(**args)

    def test(self, persist=False, gdb=False, failure=None, **args):
        for cycles in it.count(1):
            # clear disk first?
            if cycles == 1 and persist != 'noerase':
                persist = 'erase'
            else:
                persist = 'noerase'

            # exact cycle we should drop into debugger?
            if gdb and failure and failure.cycleno == cycles:
                return super().test(gdb=gdb, persist=persist, cycles=cycles,
                    failure=failure, **args)

            # run tests, but kill the program after prog/erase has
            # been hit n cycles. We exit with a special return code if the
            # program has not finished, since this isn't a test failure.
            try:
                return super().test(persist=persist, cycles=cycles, **args)
            except TestFailure as nfailure:
                if nfailure.returncode == 33:
                    continue
                else:
                    nfailure.cycleno = cycles
                    raise

class TestSuite:
    def __init__(self, path, classes=[TestCase], defines={},
            filter=None, **args):
        self.name = os.path.basename(path)
        if self.name.endswith('.toml'):
            self.name = self.name[:-len('.toml')]
        if args.get('build_dir'):
            self.toml = path
            self.path = args['build_dir'] + '/' + path
        else:
            self.toml = path
            self.path = path
        self.classes = classes
        self.defines = defines.copy()
        self.filter = filter

        with open(self.toml) as f:
            # load tests
            config = toml.load(f)

            # find line numbers
            f.seek(0)
            linenos = []
            code_linenos = []
            for i, line in enumerate(f):
                if re.match(r'\[\[\s*case\s*\]\]', line):
                    linenos.append(i+1)
                if re.match(r'code\s*=\s*(\'\'\'|""")', line):
                    code_linenos.append(i+2)

            code_linenos.reverse()

        # grab global config
        for k, v in config.get('define', {}).items():
            if k not in self.defines:
                self.defines[k] = v
        self.code = config.get('code', None)
        if self.code is not None:
            self.code_lineno = code_linenos.pop()

        # create initial test cases
        self.cases = []
        for i, (case, lineno) in enumerate(zip(config['case'], linenos)):
            # code lineno?
            if 'code' in case:
                case['code_lineno'] = code_linenos.pop()
            # merge conditions if necessary
            if 'if' in config and 'if' in case:
                case['if'] = '(%s) && (%s)' % (config['if'], case['if'])
            elif 'if' in config:
                case['if'] = config['if']
            # initialize test case
            self.cases.append(TestCase(case, filter=filter,
                suite=self, caseno=i+1, lineno=lineno, **args))

    def __str__(self):
        return self.name

    def __lt__(self, other):
        return self.name < other.name

    def permute(self, **args):
        for case in self.cases:
            # lets find all parameterized definitions, in one of [args.D,
            # suite.defines, case.defines, DEFINES]. Note that each of these
            # can be either a dict of defines, or a list of dicts, expressing
            # an initial set of permutations.
            pending = [{}]
            for inits in [self.defines, case.defines, DEFINES]:
                if not isinstance(inits, list):
                    inits = [inits]

                npending = []
                for init, pinit in it.product(inits, pending):
                    ninit = pinit.copy()
                    for k, v in init.items():
                        if k not in ninit:
                            try:
                                ninit[k] = eval(v)
                            except:
                                ninit[k] = v
                    npending.append(ninit)

                pending = npending

            # expand permutations
            pending = list(reversed(pending))
            expanded = []
            while pending:
                perm = pending.pop()
                for k, v in sorted(perm.items()):
                    if not isinstance(v, str) and isinstance(v, abc.Iterable):
                        for nv in reversed(v):
                            nperm = perm.copy()
                            nperm[k] = nv
                            pending.append(nperm)
                        break
                else:
                    expanded.append(perm)

            # generate permutations
            case.perms = []
            for i, (class_, defines) in enumerate(
                    it.product(self.classes, expanded)):
                case.perms.append(case.permute(
                    class_, defines, permno=i+1, **args))

            # also track non-unique defines
            case.defines = {}
            for k, v in case.perms[0].defines.items():
                if all(perm.defines[k] == v for perm in case.perms):
                    case.defines[k] = v

        # track all perms and non-unique defines
        self.perms = []
        for case in self.cases:
            self.perms.extend(case.perms)

        self.defines = {}
        for k, v in self.perms[0].defines.items():
            if all(perm.defines.get(k, None) == v for perm in self.perms):
                self.defines[k] = v

        return self.perms

    def build(self, **args):
        # build test files
        tf = open(self.path + '.test.tc', 'w')
        tf.write(GLOBALS)
        if self.code is not None:
            tf.write('#line %d "%s"\n' % (self.code_lineno, self.path))
            tf.write(self.code)

        tfs = {None: tf}
        for case in self.cases:
            if case.in_ not in tfs:
                tfs[case.in_] = open(self.path+'.'+
                    re.sub('(\.c)?$', '.tc', case.in_.replace('/', '.')), 'w')
                tfs[case.in_].write('#line 1 "%s"\n' % case.in_)
                with open('../../dependencies/littlefs/' + case.in_) as f:
                    for line in f:
                        tfs[case.in_].write(line)
                tfs[case.in_].write('\n')
                tfs[case.in_].write(GLOBALS)

            tfs[case.in_].write('\n')
            case.build(tfs[case.in_], **args)

        tf.write('\n')
        tf.write('const char *lfs_testbd_path;\n')
        tf.write('uint32_t lfs_testbd_cycles;\n')
        tf.write('int main(int argc, char **argv) {\n')
        tf.write(4*' '+'int case_         = (argc > 1) ? atoi(argv[1]) : 0;\n')
        tf.write(4*' '+'int perm          = (argc > 2) ? atoi(argv[2]) : 0;\n')
        tf.write(4*' '+'lfs_testbd_path   = (argc > 3) ? argv[3] : NULL;\n')
        tf.write(4*' '+'lfs_testbd_cycles = (argc > 4) ? atoi(argv[4]) : 0;\n')
        for perm in self.perms:
            # test declaration
            tf.write(4*' '+'extern void test_case%d(%s);\n' % (
                perm.caseno, ', '.join(
                    'intmax_t %s' % k for k in sorted(perm.defines)
                    if k not in perm.case.defines)))
            # test call
            tf.write(4*' '+
                'if (argc < 3 || (case_ == %d && perm == %d)) {'
                ' test_case%d(%s); '
                '}\n' % (perm.caseno, perm.permno, perm.caseno, ', '.join(
                    str(v) for k, v in sorted(perm.defines.items())
                    if k not in perm.case.defines)))
        tf.write('}\n')

        for tf in tfs.values():
            tf.close()

        # explode asserts
        sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", self.path + '.test.c', self.path + '.test.tc'])

        # write makefiles
        """
        with open(self.path + '.mk', 'w') as mk:
            mk.write(RULES.replace(4*' ', '\t') % dict(path=self.path))
            mk.write('\n')

            # add coverage hooks?
            if args.get('coverage'):
                mk.write(COVERAGE_RULES.replace(4*' ', '\t') % dict(
                    path=self.path))
                mk.write('\n')

            # add truly global defines globally
            for k, v in sorted(self.defines.items()):
                mk.write('%s.test: override CFLAGS += -D%s=%r\n'
                    % (self.path, k, v))

            for path in tfs:
                if path is None:
                    mk.write('%s: %s | %s\n' % (
                        self.path+'.test.c',
                        self.toml,
                        self.path+'.test.tc'))
                else:
                    mk.write('%s: %s %s | %s\n' % (
                        self.path+'.'+path.replace('/', '.'),
                        self.toml,
                        path,
                        self.path+'.'+re.sub('(\.c)?$', '.tc',
                            path.replace('/', '.'))))
                mk.write('\t../../dependencies/littlefs/scripts/explode_asserts.py $| -o $@\n')

        self.makefile = self.path + '.mk'
        self.target = self.path + '.test'
        return self.makefile, self.target
        """
        return self.name + '.toml.test.c', tfs, self.name, self.defines

    def test(self, **args):
        # run test suite!
        if not args.get('verbose', True):
            sys.stdout.write(self.name + ' ')
            sys.stdout.flush()
        for perm in self.perms:
            if not perm.shouldtest(**args):
                continue
            result = FAIL
            try:
                result = perm.test(**args)
            except TestFailure as failure:
                perm.result = failure
                if not args.get('verbose', True):
                    sys.stdout.write(FAIL)
                    sys.stdout.flush()
                if not args.get('keep_going'):
                    if not args.get('verbose', True):
                        sys.stdout.write('\n')
                    raise
            else:
                perm.result = PASS
                if not args.get('verbose', True):
                    if result == SKIP:
                        sys.stdout.write(SKIP)
                    else:
                        sys.stdout.write(PASS)
                    sys.stdout.flush()

        if not args.get('verbose', True):
            sys.stdout.write('\n')

def main(**args):
    if args.get('eve_platform') or args.get('eve_graphics'):
        global DEFINES
        global PROLOGUE
        global EPILOGUE
        global GLOBALS
        DEFINES = DEFINES_EVE
        PROLOGUE = PROLOGUE_EVE
        EPILOGUE = EPILOGUE_EVE
        GLOBALS = GLOBALS_EVE
    
    # figure out explicit defines
    defines = {}
    for define in args['D']:
        k, v, *_ = define.split('=', 2) + ['']
        defines[k] = v

    # and what class of TestCase to run
    classes = []
    if args.get('normal'):
        classes.append(TestCase)
    if args.get('reentrant'):
        classes.append(ReentrantTestCase)
    if args.get('valgrind'):
        classes.append(ValgrindTestCase)
    if not classes:
        classes = [TestCase]

    suites = []
    for testpath in args['test_paths']:
        # optionally specified test case/perm
        testpath, *filter = testpath.split('#')
        filter = [int(f) for f in filter]

        # figure out the suite's toml file
        if os.path.isdir(testpath):
            testpath = testpath + '/*.toml'
        elif os.path.isfile(testpath):
            testpath = testpath
        elif testpath.endswith('.toml'):
            testpath = TEST_PATHS + '/' + testpath
        else:
            testpath = TEST_PATHS + '/' + testpath + '.toml'

        # find tests
        for path in glob.glob(testpath):
            suites.append(TestSuite(path.replace("\\", "/"), classes, defines, filter, **args))

    # sort for reproducibility
    suites = sorted(suites)

    # generate permutations
    for suite in suites:
        suite.permute(**args)

    # build tests in parallel
    print('====== building ======')
    cmlf = open(TEST_PATHS + '/CMakeLists.txt', 'w')
    sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", TEST_PATHS + '/test.lfs.c', SRC_PATHS + '/lfs.c'])
    sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", TEST_PATHS + '/test.lfs_util.c', SRC_PATHS + '/lfs_util.c'])
    sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", TEST_PATHS + '/test.lfs_filebd.c', SRC_PATHS + '/bd/lfs_filebd.c'])
    sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", TEST_PATHS + '/test.lfs_rambd.c', SRC_PATHS + '/bd/lfs_rambd.c'])
    sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", TEST_PATHS + '/test.lfs_testbd.c', SRC_PATHS + '/bd/lfs_testbd.c'])
    libfs = [ "lfs.c", "lfs_util.c", "lfs_filebd.c", "lfs_rambd.c", "lfs_testbd.c" ]
    cmlf.write("PROJECT(Project C CXX)\n")
    cmlf.write("CMAKE_MINIMUM_REQUIRED(VERSION 3.22)\n")
    cmlf.write("SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin/${CMAKE_BUILD_TYPE})\n")
    cmlf.write("SET(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)\n")
    cmlf.write("SET(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)\n")
    cmlf.write("set(CMAKE_C_STANDARD 11)\n")
    cmlf.write("set(CMAKE_CXX_STANDARD 17)\n")
    cmlf.write("INCLUDE_DIRECTORIES(..)\n")
    if args.get('eve_platform') or args.get('eve_graphics'):
        cmlf.write("INCLUDE_DIRECTORIES(../../../common/eve_hal)\n")
        cmlf.write("INCLUDE_DIRECTORIES(../../../common/eve_hal/Hdr)\n")
        cmlf.write("INCLUDE_DIRECTORIES(../../../common/esd_core)\n")
        cmlf.write("IF(CMAKE_SIZEOF_VOID_P EQUAL 8)\n")
        cmlf.write("  LINK_DIRECTORIES(${CMAKE_SOURCE_DIR}/../../../common/eve_hal/Bin/Simulation/x64)\n")
        cmlf.write("  LINK_DIRECTORIES(${CMAKE_SOURCE_DIR}/../../../common/eve_hal/Bin/MSVC/x64)\n")
        cmlf.write("ELSE()\n")
        cmlf.write("  LINK_DIRECTORIES(${CMAKE_SOURCE_DIR}/../../../common/eve_hal/Bin/Simulation/x86)\n")
        cmlf.write("  LINK_DIRECTORIES(${CMAKE_SOURCE_DIR}/../../../common/eve_hal/Bin/MSVC/x86)\n")
        cmlf.write("ENDIF()\n")
        cmlf.write("ADD_DEFINITIONS(-DESD_LITTLEFS_FLASH)\n")
        cmlf.write("SET(WITH_ESD_CORE ON)\n")
        cmlf.write("SET(WITH_ESD_LITTLEFS ON)\n")
        cmlf.write("SET(ESD_LITTLFS_NOLINK ON)\n")
        cmlf.write("ADD_DEFINITIONS(-DEVE_DEFINE_FLASH)\n")
        cmlf.write("ADD_DEFINITIONS(-DEVE_TOUCH_DISABLED)\n")
        cmlf.write("ADD_DEFINITIONS(-DEVE_LITTLEFS_TESTS)\n")
        if args.get('eve_graphics'):
            cmlf.write("SET(EVE_APPS_GRAPHICS \"" + args.get('eve_graphics') + "\" CACHE STRING \"Graphics Module\")\n")
            cmlf.write("ADD_DEFINITIONS(-D" + args.get('eve_graphics') + ")\n")
        else:
            cmlf.write("SET(EVE_APPS_GRAPHICS \"EVE_GRAPHICS_VM816C\" CACHE STRING \"Graphics Module\")\n")
            cmlf.write("ADD_DEFINITIONS(-DEVE_GRAPHICS_VM816C)\n")
        cmlf.write("SET(EVE_APPS_DISPLAY \"DEFAULT\" CACHE STRING \"Display Resolution\")\n")
        if args.get('eve_platform'):
            cmlf.write("SET(EVE_APPS_PLATFORM \"" + args.get('eve_platform') + "\" CACHE STRING \"Platform Target\")\n")
            cmlf.write("ADD_DEFINITIONS(-D" + args.get('eve_platform') + ")\n")
        else:
            cmlf.write("SET(EVE_APPS_PLATFORM \"EVE_PLATFORM_BT8XXEMU\" CACHE STRING \"Platform Target\")\n")
            cmlf.write("ADD_DEFINITIONS(-DEVE_PLATFORM_BT8XXEMU)\n")
        cmlf.write("ADD_SUBDIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/../../../common ${CMAKE_CURRENT_BINARY_DIR}/common)\n")
        cmlf.write("LINK_LIBRARIES(esd_core)\n")
    targets = []
    for suite in suites:
        srcfile, tfs, target, defines = suite.build(**args)
        for path in tfs:
            cmlf.write("# " + str(path) + "\n")
        cmlf.write("ADD_EXECUTABLE(" + target + "\n")
        cmlf.write("  " + srcfile + "\n")
        for path in tfs:
            if path:
                sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", TEST_PATHS + '/' + target + ".toml." + path, TEST_PATHS + '/' + target + ".toml." + path.replace('.c', '.tc.tc')])
                cmlf.write("  " + target + ".toml." + path + "\n")
        for path in libfs:
            if not path in tfs:
                cmlf.write("  test." + path + "\n")
        cmlf.write(")\n")
        cmlf.write("TARGET_COMPILE_DEFINITIONS(" + target + " PUBLIC\n")
        for k, v in sorted(defines.items()):
            cmlf.write("  \"" + k + "=" + str(v) + "\"\n")
        targets.append(target)
        cmlf.write(")\n")
    cmlf.flush()
    cmlf.close()

    cwd = os.getcwd()
    os.chdir(TEST_PATHS)
    sp.run(["cmake", "-T", "ClangCl", "."])
    sp.run(["cmake", "--build", ".", "-j" + str(os.cpu_count() * 3 // 4)])
    os.chdir(cwd)

    """
    cmd = (['make', '-f', '../../dependencies/littlefs/Makefile'] +
        list(it.chain.from_iterable(['-f', m] for m in makefiles)) +
        [target for target in targets])
    mpty, spty = pty.openpty()
    if args.get('verbose'):
        print(' '.join(shlex.quote(c) for c in cmd))
    proc = sp.Popen(cmd, stdout=spty, stderr=spty)
    os.close(spty)
    mpty = os.fdopen(mpty, 'r', 1)
    stdout = []
    while True:
        try:
            line = mpty.readline()
        except OSError as e:
            if e.errno == errno.EIO:
                break
            raise
        if not line:
            break;
        stdout.append(line)
        if args.get('verbose'):
            sys.stdout.write(line)
        # intercept warnings
        m = re.match(
            '^{0}([^:]+):(\d+):(?:\d+:)?{0}{1}:{0}(.*)$'
            .format('(?:\033\[[\d;]*.| )*', 'warning'),
            line)
        if m and not args.get('verbose'):
            try:
                with open(m.group(1)) as f:
                    lineno = int(m.group(2))
                    line = next(it.islice(f, lineno-1, None)).strip('\n')
                sys.stdout.write(
                    "\033[01m{path}:{lineno}:\033[01;35mwarning:\033[m "
                    "{message}\n{line}\n\n".format(
                        path=m.group(1), line=line, lineno=lineno,
                        message=m.group(3)))
            except:
                pass
    proc.wait()
    if proc.returncode != 0:
        if not args.get('verbose'):
            for line in stdout:
                sys.stdout.write(line)
        sys.exit(-1)
    """

    print('built %d test suites, %d test cases, %d permutations' % (
        len(suites),
        sum(len(suite.cases) for suite in suites),
        sum(len(suite.perms) for suite in suites)))

    total = 0
    for suite in suites:
        for perm in suite.perms:
            total += perm.shouldtest(**args)
    if total != sum(len(suite.perms) for suite in suites):
        print('filtered down to %d permutations' % total)

    # only requested to build?
    if args.get('build'):
        return 0

    print('====== testing ======')
    try:
        for suite in suites:
            suite.test(**args)
    except TestFailure:
        pass

    print('====== results ======')
    passed = 0
    failed = 0
    for suite in suites:
        for perm in suite.perms:
            if perm.result == PASS:
                passed += 1
            elif isinstance(perm.result, TestFailure):
                sys.stdout.write(
                    "\033[01m{path}:{lineno}:\033[01;31mfailure:\033[m "
                    "{perm} failed\n".format(
                        perm=perm, path=perm.suite.path, lineno=perm.lineno,
                        returncode=perm.result.returncode or 0))
                if perm.result.stdout:
                    if perm.result.assert_:
                        stdout = perm.result.stdout[:-1]
                    else:
                        stdout = perm.result.stdout
                    for line in stdout[-5:]:
                        sys.stdout.write(line)
                if perm.result.assert_:
                    sys.stdout.write(
                        "\033[01m{path}:{lineno}:\033[01;31massert:\033[m "
                        "{message}\n{line}\n".format(
                            **perm.result.assert_))
                sys.stdout.write('\n')
                failed += 1

    if args.get('coverage'):
        # collect coverage info
        # why -j1? lcov doesn't work in parallel because of gcov limitations
        cmd = (['make', '-j1', '-f', 'Makefile'] +
            list(it.chain.from_iterable(['-f', m] for m in makefiles)) +
            (['COVERAGETARGET=%s' % args['coverage']]
                if isinstance(args['coverage'], str) else []) +
            [suite.path + '.info' for suite in suites
                if any(perm.result == PASS for perm in suite.perms)])
        if args.get('verbose'):
            print(' '.join(shlex.quote(c) for c in cmd))
        proc = sp.Popen(cmd,
            stdout=sp.PIPE if not args.get('verbose') else None,
            stderr=sp.STDOUT if not args.get('verbose') else None,
            universal_newlines=True)
        stdout = []
        for line in proc.stdout:
            stdout.append(line)
        proc.wait()
        if proc.returncode != 0:
            if not args.get('verbose'):
                for line in stdout:
                    sys.stdout.write(line)
            sys.exit(-1)

    if args.get('gdb'):
        failure = None
        for suite in suites:
            for perm in suite.perms:
                if isinstance(perm.result, TestFailure):
                    failure = perm.result
        if failure is not None:
            print('======= gdb ======')
            # drop into gdb
            failure.case.test(failure=failure, **args)
            sys.exit(0)

    print('tests passed %d/%d (%.1f%%)' % (passed, total,
        100*(passed/total if total else 1.0)))
    print('tests failed %d/%d (%.1f%%)' % (failed, total,
        100*(failed/total if total else 1.0)))
    return 1 if failed > 0 else 0

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(
        description="Run parameterized tests in various configurations.")
    parser.add_argument('test_paths', nargs='*', default=[TEST_PATHS],
        help="Description of test(s) to run. By default, this is all tests \
            found in the \"{0}\" directory. Here, you can specify a different \
            directory of tests, a specific file, a suite by name, and even \
            specific test cases and permutations. For example \
            \"test_dirs#1\" or \"{0}/test_dirs.toml#1#1\".".format(TEST_PATHS))
    parser.add_argument('-D', action='append', default=[],
        help="Overriding parameter definitions.")
    parser.add_argument('-v', '--verbose', action='store_true',
        help="Output everything that is happening.")
    parser.add_argument('-k', '--keep-going', action='store_true',
        help="Run all tests instead of stopping on first error. Useful for CI.")
    parser.add_argument('-p', '--persist', choices=['erase', 'noerase'],
        nargs='?', const='erase',
        help="Store disk image in a file.")
    parser.add_argument('-b', '--build', action='store_true',
        help="Only build the tests, do not execute.")
    parser.add_argument('-g', '--gdb', choices=['init', 'main', 'assert'],
        nargs='?', const='assert',
        help="Drop into gdb on test failure.")
    parser.add_argument('--no-internal', action='store_true',
        help="Don't run tests that require internal knowledge.")
    parser.add_argument('-n', '--normal', action='store_true',
        help="Run tests normally.")
    parser.add_argument('-r', '--reentrant', action='store_true',
        help="Run reentrant tests with simulated power-loss.")
    parser.add_argument('--valgrind', action='store_true',
        help="Run non-leaky tests under valgrind to check for memory leaks.")
    parser.add_argument('--exec', default=[], type=lambda e: e.split(),
        help="Run tests with another executable prefixed on the command line.")
    parser.add_argument('--disk',
        help="Specify a file to use for persistent/reentrant tests.")
    parser.add_argument('--coverage', type=lambda x: x if x else True,
        nargs='?', const='',
        help="Collect coverage information during testing. This uses lcov/gcov \
            to accumulate coverage information into *.info files. May also \
            a path to a *.info file to accumulate coverage info into.")
    parser.add_argument('--build-dir',
        help="Build relative to the specified directory instead of the \
            current directory.")
    parser.add_argument('--eve-platform',
        help="Build and run on the specified EVE platform.")
    parser.add_argument('--eve-graphics',
        help="Build and run for the specified EVE graphics chip.")

    sys.exit(main(**vars(parser.parse_args())))
