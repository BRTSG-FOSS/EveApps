--- ../../dependencies/littlefs/scripts/test.py	2022-06-29 13:23:45.007848100 +0800
+++ test_littlefs.py	2022-06-30 15:02:39.387651400 +0800
@@ -1,5 +1,35 @@
 #!/usr/bin/env python3
 
+# Copyright (c) 2022, The littlefs authors.
+# Copyright (c) 2017, Arm Limited. All rights reserved.
+# 
+# This file has been modified by the following contributers:
+# Copyright (c) 2022, Bridgetek Pte Ltd.
+# 
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+# 
+# -  Redistributions of source code must retain the above copyright notice, this
+#    list of conditions and the following disclaimer.
+# -  Redistributions in binary form must reproduce the above copyright notice, this
+#    list of conditions and the following disclaimer in the documentation and/or
+#    other materials provided with the distribution.
+# -  Neither the name of ARM nor the names of its contributors may be used to
+#    endorse or promote products derived from this software without specific prior
+#    written permission.
+# 
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+# 
+
 # This script manages littlefs tests, which are configured with
 # .toml files stored in the tests directory.
 #
@@ -16,18 +46,19 @@
 import sys
 import copy
 import shlex
-import pty
+# import pty
 import errno
 import signal
 
-TEST_PATHS = 'tests'
+TEST_PATHS = '../../dependencies/littlefs/tests'
+SRC_PATHS = '../../dependencies/littlefs'
 RULES = """
 # add block devices to sources
-TESTSRC ?= $(SRC) $(wildcard bd/*.c)
+TESTSRC ?= $(SRC) $(wildcard ../../dependencies/littlefs/bd/*.c)
 
 define FLATTEN
 %(path)s%%$(subst /,.,$(target)): $(target)
-    ./scripts/explode_asserts.py $$< -o $$@
+    ../../dependencies/littlefs/scripts/explode_asserts.py $$< -o $$@
 endef
 $(foreach target,$(TESTSRC),$(eval $(FLATTEN)))
 
@@ -125,8 +156,8 @@
     // epilogue
     lfs_testbd_destroy(&cfg) => 0;
 """
-PASS = '\033[32m✓\033[0m'
-FAIL = '\033[31m✗\033[0m'
+PASS = 'p'
+FAIL = 'F'
 
 class TestFailure(Exception):
     def __init__(self, case, returncode=None, stdout=None, assert_=None):
@@ -235,7 +266,7 @@
     def test(self, exec=[], persist=False, cycles=None,
             gdb=False, failure=None, disk=None, **args):
         # build command
-        cmd = exec + ['./%s.test' % self.suite.path,
+        cmd = exec + ['../../dependencies/littlefs/tests/Debug/%s.exe' % self.suite.name,
             repr(self.caseno), repr(self.permno)]
 
         # persist disk or keep in RAM for speed?
@@ -276,6 +307,47 @@
             sys.exit(sp.call(ncmd))
 
         # run test case!
+        returncode = 0
+        output = ""
+        try:
+            output = sp.check_output(cmd, text=True)
+        except sp.CalledProcessError as e:
+            errorcode = e.returncode
+            output = e.output
+        except OSError as e:
+            if e.errno != errno.EIO:
+                raise
+        except KeyboardInterrupt as e:
+            raise TestFailure(self, 1, [], None)
+        stdout = output.splitlines()
+        assert_ = None
+        for line_ in stdout:
+            line = line_ + '\n'
+            if args.get('verbose'):
+                sys.stdout.write(line)
+            # intercept asserts
+            m = re.match(
+                '^{0}([^:]+):(\d+):(?:\d+:)?{0}{1}:{0}(.*)$'
+                .format('(?:\033\[[\d;]*.| )*', 'assert'),
+                line)
+            if m and assert_ is None:
+                try:
+                    with open(m.group(1)) as f:
+                        lineno = int(m.group(2))
+                        line = (next(it.islice(f, lineno-1, None))
+                            .strip('\n'))
+                    assert_ = {
+                        'path': m.group(1),
+                        'line': line,
+                        'lineno': lineno,
+                        'message': m.group(3)}
+                except:
+                    pass
+        if returncode != 0 or assert_:
+            raise TestFailure(self, returncode, stdout, assert_)
+        else:
+            return PASS
+        """
         mpty, spty = pty.openpty()
         if args.get('verbose'):
             print(' '.join(shlex.quote(c) for c in cmd))
@@ -324,6 +396,7 @@
             raise TestFailure(self, proc.returncode, stdout, assert_)
         else:
             return PASS
+        """
 
 class ValgrindTestCase(TestCase):
     def __init__(self, config, **args):
@@ -519,7 +592,7 @@
                 tfs[case.in_] = open(self.path+'.'+
                     re.sub('(\.c)?$', '.tc', case.in_.replace('/', '.')), 'w')
                 tfs[case.in_].write('#line 1 "%s"\n' % case.in_)
-                with open(case.in_) as f:
+                with open('../../dependencies/littlefs/' + case.in_) as f:
                     for line in f:
                         tfs[case.in_].write(line)
                 tfs[case.in_].write('\n')
@@ -554,7 +627,11 @@
         for tf in tfs.values():
             tf.close()
 
+        # explode asserts
+        sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", self.path + '.test.c', self.path + '.test.tc'])
+
         # write makefiles
+        """
         with open(self.path + '.mk', 'w') as mk:
             mk.write(RULES.replace(4*' ', '\t') % dict(path=self.path))
             mk.write('\n')
@@ -583,11 +660,13 @@
                         path,
                         self.path+'.'+re.sub('(\.c)?$', '.tc',
                             path.replace('/', '.'))))
-                mk.write('\t./scripts/explode_asserts.py $| -o $@\n')
+                mk.write('\t../../dependencies/littlefs/scripts/explode_asserts.py $| -o $@\n')
 
         self.makefile = self.path + '.mk'
         self.target = self.path + '.test'
         return self.makefile, self.target
+        """
+        return self.name + '.toml.test.c', tfs, self.name, self.defines
 
     def test(self, **args):
         # run test suite!
@@ -654,7 +733,7 @@
 
         # find tests
         for path in glob.glob(testpath):
-            suites.append(TestSuite(path, classes, defines, filter, **args))
+            suites.append(TestSuite(path.replace("\\", "/"), classes, defines, filter, **args))
 
     # sort for reproducibility
     suites = sorted(suites)
@@ -665,14 +744,47 @@
 
     # build tests in parallel
     print('====== building ======')
-    makefiles = []
+    cmlf = open(TEST_PATHS + '/CMakeLists.txt', 'w')
+    sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", TEST_PATHS + '/test.lfs.c', SRC_PATHS + '/lfs.c'])
+    sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", TEST_PATHS + '/test.lfs_util.c', SRC_PATHS + '/lfs_util.c'])
+    sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", TEST_PATHS + '/test.lfs_filebd.c', SRC_PATHS + '/bd/lfs_filebd.c'])
+    sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", TEST_PATHS + '/test.lfs_rambd.c', SRC_PATHS + '/bd/lfs_rambd.c'])
+    sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", TEST_PATHS + '/test.lfs_testbd.c', SRC_PATHS + '/bd/lfs_testbd.c'])
+    libfs = [ "lfs.c", "lfs_util.c", "lfs_filebd.c", "lfs_rambd.c", "lfs_testbd.c" ]
+    cmlf.write("PROJECT(Project)\n")
+    cmlf.write("CMAKE_MINIMUM_REQUIRED(VERSION 3.22)\n")
+    cmlf.write("INCLUDE_DIRECTORIES(..)\n")
     targets = []
     for suite in suites:
-        makefile, target = suite.build(**args)
-        makefiles.append(makefile)
+        srcfile, tfs, target, defines = suite.build(**args)
+        for path in tfs:
+            cmlf.write("# " + str(path) + "\n")
+        cmlf.write("ADD_EXECUTABLE(" + target + "\n")
+        cmlf.write("  " + srcfile + "\n")
+        for path in tfs:
+            if path:
+                sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", TEST_PATHS + '/' + target + ".toml." + path, TEST_PATHS + '/' + target + ".toml." + path.replace('.c', '.tc.tc')])
+                cmlf.write("  " + target + ".toml." + path + "\n")
+        for path in libfs:
+            if not path in tfs:
+                cmlf.write("  test." + path + "\n")
+        cmlf.write(")\n")
+        cmlf.write("TARGET_COMPILE_DEFINITIONS(" + target + " PUBLIC\n")
+        for k, v in sorted(defines.items()):
+            cmlf.write("  \"" + k + "=" + str(v) + "\"\n")
         targets.append(target)
+        cmlf.write(")\n")
+    cmlf.flush()
+    cmlf.close()
+
+    cwd = os.getcwd()
+    os.chdir(TEST_PATHS)
+    sp.run(["cmake", "-T", "ClangCl", "."])
+    sp.run(["cmake", "--build", "."])
+    os.chdir(cwd)
 
-    cmd = (['make', '-f', 'Makefile'] +
+    """
+    cmd = (['make', '-f', '../../dependencies/littlefs/Makefile'] +
         list(it.chain.from_iterable(['-f', m] for m in makefiles)) +
         [target for target in targets])
     mpty, spty = pty.openpty()
@@ -717,6 +829,7 @@
             for line in stdout:
                 sys.stdout.write(line)
         sys.exit(-1)
+    """
 
     print('built %d test suites, %d test cases, %d permutations' % (
         len(suites),
