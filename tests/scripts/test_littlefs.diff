--- ../../dependencies/littlefs/scripts/test.py	2022-07-09 17:30:49.954927800 +0800
+++ test_littlefs.py	2022-07-05 04:11:33.644093500 +0800
@@ -1,5 +1,35 @@
 #!/usr/bin/env python3
 
+# Copyright (c) 2022, The littlefs authors.
+# Copyright (c) 2017, Arm Limited. All rights reserved.
+# 
+# This file has been modified by the following contributers:
+# Copyright (c) 2022, Bridgetek Pte Ltd.
+# 
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+# 
+# -  Redistributions of source code must retain the above copyright notice, this
+#    list of conditions and the following disclaimer.
+# -  Redistributions in binary form must reproduce the above copyright notice, this
+#    list of conditions and the following disclaimer in the documentation and/or
+#    other materials provided with the distribution.
+# -  Neither the name of ARM nor the names of its contributors may be used to
+#    endorse or promote products derived from this software without specific prior
+#    written permission.
+# 
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+# 
+
 # This script manages littlefs tests, which are configured with
 # .toml files stored in the tests directory.
 #
@@ -16,18 +46,19 @@
 import sys
 import copy
 import shlex
-import pty
+# import pty
 import errno
 import signal
 
-TEST_PATHS = 'tests'
+TEST_PATHS = '../../dependencies/littlefs/tests'
+SRC_PATHS = '../../dependencies/littlefs'
 RULES = """
 # add block devices to sources
-TESTSRC ?= $(SRC) $(wildcard bd/*.c)
+TESTSRC ?= $(SRC) $(wildcard ../../dependencies/littlefs/bd/*.c)
 
 define FLATTEN
 %(path)s%%$(subst /,.,$(target)): $(target)
-    ./scripts/explode_asserts.py $$< -o $$@
+    ../../dependencies/littlefs/scripts/explode_asserts.py $$< -o $$@
 endef
 $(foreach target,$(TESTSRC),$(eval $(FLATTEN)))
 
@@ -73,6 +104,16 @@
 extern const char *lfs_testbd_path;
 extern uint32_t lfs_testbd_cycles;
 """
+GLOBALS_EVE = """
+//////////////// AUTOGENERATED TEST ////////////////
+#include <Esd_Core.h>
+#include <Esd_LittleFS.h>
+#include "lfs.h"
+#include "bd/lfs_testbd.h"
+#include <stdio.h>
+extern const char *lfs_testbd_path;
+extern uint32_t lfs_testbd_cycles;
+"""
 DEFINES = {
     'LFS_READ_SIZE': 16,
     'LFS_PROG_SIZE': 'LFS_READ_SIZE',
@@ -85,6 +126,18 @@
     'LFS_ERASE_CYCLES': 0,
     'LFS_BADBLOCK_BEHAVIOR': 'LFS_TESTBD_BADBLOCK_PROGERROR',
 }
+DEFINES_EVE = {
+    'LFS_READ_SIZE': 64,
+    'LFS_PROG_SIZE': 256,
+    'LFS_BLOCK_SIZE': 4096,
+    'LFS_BLOCK_COUNT': '(EVE_FLASH_SIZE * (1024 * 1024 / 4096) - 1)',
+    'LFS_BLOCK_CYCLES': -1,
+    'LFS_CACHE_SIZE': 'LFS_PROG_SIZE',
+    'LFS_LOOKAHEAD_SIZE': 32,
+    'LFS_ERASE_VALUE': 0xff,
+    'LFS_ERASE_CYCLES': 0,
+    'LFS_BADBLOCK_BEHAVIOR': 'LFS_TESTBD_BADBLOCK_PROGERROR',
+}
 PROLOGUE = """
     // prologue
     __attribute__((unused)) lfs_t lfs;
@@ -121,12 +174,133 @@
 
     lfs_testbd_createcfg(&cfg, lfs_testbd_path, &bdcfg) => 0;
 """
+PROLOGUE_EVE = """
+    // prologue
+    __attribute__((unused)) lfs_t lfs;
+    __attribute__((unused)) lfs_file_t file;
+    __attribute__((unused)) lfs_dir_t dir;
+    __attribute__((unused)) struct lfs_info info;
+    __attribute__((unused)) char path[1024];
+    __attribute__((unused)) uint8_t buffer[(1024 > LFS_BLOCK_SIZE * 4) ? (1024) : (LFS_BLOCK_SIZE * 4)];
+    __attribute__((unused)) lfs_size_t size;
+    __attribute__((unused)) int err;
+    __attribute__((unused)) struct lfs_config cfg;
+    __attribute__((unused)) Esd_Context esdcontext;
+    __attribute__((unused)) Esd_Context *ec = &esdcontext;
+    __attribute__((unused)) EVE_HalContext *phost = &esdcontext.HalContext;
+    if (LFS_ERASE_VALUE != 0xFF)
+    {
+        eve_printf("Erase value not applicable, don't run test\\n");
+        return;
+    }
+    if (LFS_ERASE_CYCLES)
+    {
+        eve_printf("Erase cycle tests are not applicable, don't run test\\n");
+        return;
+    }
+    Esd_Initialize();
+    {
+        Esd_Parameters ep;
+        Esd_Defaults(&ep);
+#ifdef ESD_FLASH_FILES
+        wcscpy_s(ep.FlashFilePaths[ESD_FLASH_BT815], _countof(ep.FlashFilePaths[ESD_FLASH_BT815]), L"..\\\\..\\\\common\\\\eve_flash\\\\BT815-unified.blob");
+#if (EVE_SUPPORT_CHIPID >= EVE_BT817)
+        wcscpy_s(ep.FlashFilePaths[ESD_FLASH_BT817], _countof(ep.FlashFilePaths[ESD_FLASH_BT817]), L"..\\\\..\\\\common\\\\eve_flash\\\\BT817-unified.blob");
+#endif
+#endif
+        Esd_Open(ec, &ep) => true;
+        Esd_SetCurrent(ec);
+        Esd_Start(ec);
+        Esd_LittleFS_Mount(ec);
+        Esd_LittleFS_Unmount(ec);
+        cfg = ec->LfsConfig;
+        LFS_ASSERT(cfg.block_size >= LFS_BLOCK_SIZE);
+        cfg.block_size = LFS_BLOCK_SIZE;
+        LFS_ASSERT(cfg.block_count >= LFS_BLOCK_COUNT);
+        cfg.block_count = LFS_BLOCK_COUNT;
+        cfg.block_cycles = LFS_BLOCK_CYCLES;
+        if (sizeof(ec->LfsReadBuffer) < LFS_CACHE_SIZE
+            || sizeof(ec->LfsProgBuffer) < LFS_CACHE_SIZE)
+        {
+            cfg.read_buffer = NULL;
+            cfg.prog_buffer = NULL;
+        }
+        cfg.cache_size = LFS_CACHE_SIZE;
+        if (sizeof(ec->LfsLookaheadBuffer) < LFS_LOOKAHEAD_SIZE)
+        {
+            cfg.lookahead_buffer = NULL;
+        }
+        cfg.lookahead_size = LFS_LOOKAHEAD_SIZE;
+        cfg.flags = 0;
+    }
+    {
+        int chipId = EVE_CHIPID;
+        char deviceName[64] = "Bridgetek BT8XX";
+        char *chipPrefix = (EVE_GEN >= EVE3 || chipId >= EVE_BT880) ? "BT" : "FT";
+        char *chipBranding = (EVE_GEN >= EVE3 || chipId >= EVE_BT880) ? "Bridgetek" : "FTDI";
+        sprintf(deviceName, "%s %s%lx", chipBranding, chipPrefix, (unsigned long)EVE_shortChipId(chipId));
+        // EVE_Hal_wr32(phost, REG_MACRO_0, BITMAP_TRANSFORM_F(256));
+        EVE_CoCmd_memZero(phost, 0, 4096 * 2);
+        // EVE_CoCmd_memSet(phost, 0, 0xFF, 4096 * 2);
+        EVE_CoCmd_dlStart(phost);
+        EVE_CoDl_clearColorRgb(phost, 0, 0, 0);
+        EVE_CoDl_clear(phost, 1, 1, 1);
+        EVE_CoDl_blendFunc(phost, SRC_ALPHA, ONE);
+        EVE_CoDl_colorRgb(phost, 64, 192, 64);
+        EVE_CoDl_bitmapHandle(phost, 0);
+        EVE_CoCmd_setBitmap(phost, 0, TEXT8X8, 512, 512);
+        EVE_CoCmd_dl(phost, BITMAP_SIZE_H(2, 4));
+        EVE_CoCmd_dl(phost, BITMAP_SIZE(NEAREST, REPEAT, REPEAT, 0, 0));
+        EVE_CoDl_bitmapHandle(phost, 1);
+        EVE_CoCmd_setBitmap(phost, 4096, TEXT8X8, 512, 512);
+        EVE_CoCmd_dl(phost, BITMAP_SIZE_H(2, 4));
+        EVE_CoCmd_dl(phost, BITMAP_SIZE(NEAREST, REPEAT, REPEAT, 0, 0));
+        EVE_CoDl_begin(phost, BITMAPS);
+        // EVE_CoDl_macro(phost, 0);
+        EVE_CoDl_vertex2ii(phost, 0, 0, 0, 0);
+        EVE_CoDl_vertex2ii(phost, 0, 0, 1, 0);
+        EVE_CoDl_end(phost);
+        EVE_CoDl_blendFunc_default(phost);
+        // EVE_CoCmd_dl(phost, BITMAP_TRANSFORM_F(0));
+        EVE_CoDl_colorRgb(phost, 255, 255, 255);
+        EVE_CoCmd_text(phost, 5, 5, 30, 0, deviceName);
+        EVE_CoCmd_text(phost, 5, 45, 28, 0, "EVE LittleFS Tests");
+        // EVE_CoDl_macro(phost, 0);
+        // EVE_CoDl_begin(phost, POINTS);
+        // EVE_CoDl_pointSize(phost, 180);
+        // EVE_CoDl_vertexFormat(phost, 1);
+        // EVE_CoDl_vertex2f(phost, 45, 45);
+        // EVE_CoDl_end(phost);
+        EVE_CoDl_display(phost);
+        EVE_CoCmd_swap(phost);
+        EVE_Hal_flush(phost);
+    }
+    if (!lfs_testbd_path || !strcmp(lfs_testbd_path, "test_littlefs.disk.erase"))
+    {
+        EVE_CoCmd_memSet(phost, 0, 0xFF, 4096 * 2);
+        EVE_CoCmd_flashUpdate(phost, 4096, 0, 4096 * 2);
+        EVE_Cmd_waitFlush(phost) => true;
+    }
+"""
 EPILOGUE = """
     // epilogue
     lfs_testbd_destroy(&cfg) => 0;
 """
-PASS = '\033[32m✓\033[0m'
-FAIL = '\033[31m✗\033[0m'
+EPILOGUE_EVE = """
+    // epilogue
+    if (!lfs_testbd_path)
+    {
+        EVE_CoCmd_memSet(phost, 0, 0xFF, 4096 * 2);
+        EVE_CoCmd_flashUpdate(phost, 4096, 0, 4096 * 2);
+        EVE_Cmd_waitFlush(phost) => true;
+    }
+    Esd_Stop(ec);
+    Esd_Close(ec);
+    Esd_Release();
+"""
+PASS = 'p'
+FAIL = 'F'
+SKIP = 's'
 
 class TestFailure(Exception):
     def __init__(self, case, returncode=None, stdout=None, assert_=None):
@@ -235,7 +409,7 @@
     def test(self, exec=[], persist=False, cycles=None,
             gdb=False, failure=None, disk=None, **args):
         # build command
-        cmd = exec + ['./%s.test' % self.suite.path,
+        cmd = exec + ['../../dependencies/littlefs/tests/bin/Debug/%s.exe' % self.suite.name,
             repr(self.caseno), repr(self.permno)]
 
         # persist disk or keep in RAM for speed?
@@ -250,7 +424,11 @@
                         print('truncate --size=0', disk)
                 except FileNotFoundError:
                     pass
-
+            if args.get('eve_platform') or args.get('eve_graphics'):
+                if persist != 'noerase':
+                    disk = 'test_littlefs.disk.erase'
+                else:
+                    disk = 'test_littlefs.disk.noerase'
             cmd.append(disk)
 
         # simulate power-loss after n cycles?
@@ -276,6 +454,53 @@
             sys.exit(sp.call(ncmd))
 
         # run test case!
+        returncode = 0
+        output = ""
+        anyerror = False
+        try:
+            output = sp.check_output(cmd, text=True)
+        except sp.CalledProcessError as e:
+            anyerror = True
+            errorcode = e.returncode
+            output = e.output
+        except OSError as e:
+            if e.errno != errno.EIO:
+                raise
+        except KeyboardInterrupt as e:
+            raise TestFailure(self, 1, [], None)
+        stdout = output.splitlines()
+        assert_ = None
+        rescode = PASS
+        for idx, line in enumerate(stdout):
+            if "not applicable, don't run test" in line:
+                rescode = SKIP
+            stdout[idx] = line + '\n'
+        for line in stdout:
+            if args.get('verbose'):
+                sys.stdout.write(line)
+            # intercept asserts
+            m = re.match(
+                '^{0}([^:]+):(\d+):(?:\d+:)?{0}{1}:{0}(.*)$'
+                .format('(?:\033\[[\d;]*.| )*', 'assert'),
+                line)
+            if m and assert_ is None:
+                try:
+                    with open(m.group(1)) as f:
+                        lineno = int(m.group(2))
+                        line = (next(it.islice(f, lineno-1, None))
+                            .strip('\n'))
+                    assert_ = {
+                        'path': m.group(1),
+                        'line': line,
+                        'lineno': lineno,
+                        'message': m.group(3)}
+                except:
+                    pass
+        if returncode != 0 or assert_ or anyerror:
+            raise TestFailure(self, returncode, stdout, assert_)
+        else:
+            return rescode
+        """
         mpty, spty = pty.openpty()
         if args.get('verbose'):
             print(' '.join(shlex.quote(c) for c in cmd))
@@ -324,6 +549,7 @@
             raise TestFailure(self, proc.returncode, stdout, assert_)
         else:
             return PASS
+        """
 
 class ValgrindTestCase(TestCase):
     def __init__(self, config, **args):
@@ -519,7 +745,7 @@
                 tfs[case.in_] = open(self.path+'.'+
                     re.sub('(\.c)?$', '.tc', case.in_.replace('/', '.')), 'w')
                 tfs[case.in_].write('#line 1 "%s"\n' % case.in_)
-                with open(case.in_) as f:
+                with open('../../dependencies/littlefs/' + case.in_) as f:
                     for line in f:
                         tfs[case.in_].write(line)
                 tfs[case.in_].write('\n')
@@ -554,7 +780,11 @@
         for tf in tfs.values():
             tf.close()
 
+        # explode asserts
+        sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", self.path + '.test.c', self.path + '.test.tc'], check=True)
+
         # write makefiles
+        """
         with open(self.path + '.mk', 'w') as mk:
             mk.write(RULES.replace(4*' ', '\t') % dict(path=self.path))
             mk.write('\n')
@@ -583,11 +813,13 @@
                         path,
                         self.path+'.'+re.sub('(\.c)?$', '.tc',
                             path.replace('/', '.'))))
-                mk.write('\t./scripts/explode_asserts.py $| -o $@\n')
+                mk.write('\t../../dependencies/littlefs/scripts/explode_asserts.py $| -o $@\n')
 
         self.makefile = self.path + '.mk'
         self.target = self.path + '.test'
         return self.makefile, self.target
+        """
+        return self.name + '.toml.test.c', tfs, self.name, self.defines
 
     def test(self, **args):
         # run test suite!
@@ -597,7 +829,7 @@
         for perm in self.perms:
             if not perm.shouldtest(**args):
                 continue
-
+            result = FAIL
             try:
                 result = perm.test(**args)
             except TestFailure as failure:
@@ -612,13 +844,26 @@
             else:
                 perm.result = PASS
                 if not args.get('verbose', True):
-                    sys.stdout.write(PASS)
+                    if result == SKIP:
+                        sys.stdout.write(SKIP)
+                    else:
+                        sys.stdout.write(PASS)
                     sys.stdout.flush()
 
         if not args.get('verbose', True):
             sys.stdout.write('\n')
 
 def main(**args):
+    if args.get('eve_platform') or args.get('eve_graphics'):
+        global DEFINES
+        global PROLOGUE
+        global EPILOGUE
+        global GLOBALS
+        DEFINES = DEFINES_EVE
+        PROLOGUE = PROLOGUE_EVE
+        EPILOGUE = EPILOGUE_EVE
+        GLOBALS = GLOBALS_EVE
+    
     # figure out explicit defines
     defines = {}
     for define in args['D']:
@@ -654,7 +899,7 @@
 
         # find tests
         for path in glob.glob(testpath):
-            suites.append(TestSuite(path, classes, defines, filter, **args))
+            suites.append(TestSuite(path.replace("\\", "/"), classes, defines, filter, **args))
 
     # sort for reproducibility
     suites = sorted(suites)
@@ -665,14 +910,86 @@
 
     # build tests in parallel
     print('====== building ======')
-    makefiles = []
+    cmlf = open(TEST_PATHS + '/CMakeLists.txt', 'w')
+    sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", TEST_PATHS + '/test.lfs.c', SRC_PATHS + '/lfs.c'], check=True)
+    sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", TEST_PATHS + '/test.lfs_util.c', SRC_PATHS + '/lfs_util.c'], check=True)
+    sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", TEST_PATHS + '/test.lfs_filebd.c', SRC_PATHS + '/bd/lfs_filebd.c'], check=True)
+    sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", TEST_PATHS + '/test.lfs_rambd.c', SRC_PATHS + '/bd/lfs_rambd.c'], check=True)
+    sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", TEST_PATHS + '/test.lfs_testbd.c', SRC_PATHS + '/bd/lfs_testbd.c'], check=True)
+    libfs = [ "lfs.c", "lfs_util.c", "lfs_filebd.c", "lfs_rambd.c", "lfs_testbd.c" ]
+    cmlf.write("PROJECT(Project C CXX)\n")
+    cmlf.write("CMAKE_MINIMUM_REQUIRED(VERSION 3.22)\n")
+    cmlf.write("SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin/${CMAKE_BUILD_TYPE})\n")
+    cmlf.write("SET(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)\n")
+    cmlf.write("SET(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)\n")
+    cmlf.write("set(CMAKE_C_STANDARD 11)\n")
+    cmlf.write("set(CMAKE_CXX_STANDARD 17)\n")
+    cmlf.write("INCLUDE_DIRECTORIES(..)\n")
+    if args.get('eve_platform') or args.get('eve_graphics'):
+        cmlf.write("INCLUDE_DIRECTORIES(../../../common/eve_hal)\n")
+        cmlf.write("INCLUDE_DIRECTORIES(../../../common/eve_hal/Hdr)\n")
+        cmlf.write("INCLUDE_DIRECTORIES(../../../common/esd_core)\n")
+        cmlf.write("IF(CMAKE_SIZEOF_VOID_P EQUAL 8)\n")
+        cmlf.write("  LINK_DIRECTORIES(${CMAKE_SOURCE_DIR}/../../../common/eve_hal/Bin/Simulation/x64)\n")
+        cmlf.write("  LINK_DIRECTORIES(${CMAKE_SOURCE_DIR}/../../../common/eve_hal/Bin/MSVC/x64)\n")
+        cmlf.write("ELSE()\n")
+        cmlf.write("  LINK_DIRECTORIES(${CMAKE_SOURCE_DIR}/../../../common/eve_hal/Bin/Simulation/x86)\n")
+        cmlf.write("  LINK_DIRECTORIES(${CMAKE_SOURCE_DIR}/../../../common/eve_hal/Bin/MSVC/x86)\n")
+        cmlf.write("ENDIF()\n")
+        cmlf.write("ADD_DEFINITIONS(-DESD_LITTLEFS_FLASH)\n")
+        cmlf.write("SET(WITH_ESD_CORE ON)\n")
+        cmlf.write("SET(WITH_ESD_LITTLEFS ON)\n")
+        cmlf.write("SET(ESD_LITTLFS_NOLINK ON)\n")
+        cmlf.write("ADD_DEFINITIONS(-DEVE_DEFINE_FLASH)\n")
+        cmlf.write("ADD_DEFINITIONS(-DEVE_TOUCH_DISABLED)\n")
+        cmlf.write("ADD_DEFINITIONS(-DEVE_LITTLEFS_TESTS)\n")
+        cmlf.write("ADD_DEFINITIONS(-DEVE_DEBUG_BREAK_SIGABRT)\n")
+        if args.get('eve_graphics'):
+            cmlf.write("SET(EVE_APPS_GRAPHICS \"" + args.get('eve_graphics') + "\" CACHE STRING \"Graphics Module\")\n")
+            cmlf.write("ADD_DEFINITIONS(-D" + args.get('eve_graphics') + ")\n")
+        else:
+            cmlf.write("SET(EVE_APPS_GRAPHICS \"EVE_GRAPHICS_VM816C\" CACHE STRING \"Graphics Module\")\n")
+            cmlf.write("ADD_DEFINITIONS(-DEVE_GRAPHICS_VM816C)\n")
+        cmlf.write("SET(EVE_APPS_DISPLAY \"DEFAULT\" CACHE STRING \"Display Resolution\")\n")
+        if args.get('eve_platform'):
+            cmlf.write("SET(EVE_APPS_PLATFORM \"" + args.get('eve_platform') + "\" CACHE STRING \"Platform Target\")\n")
+            cmlf.write("ADD_DEFINITIONS(-D" + args.get('eve_platform') + ")\n")
+        else:
+            cmlf.write("SET(EVE_APPS_PLATFORM \"EVE_PLATFORM_BT8XXEMU\" CACHE STRING \"Platform Target\")\n")
+            cmlf.write("ADD_DEFINITIONS(-DEVE_PLATFORM_BT8XXEMU)\n")
+        cmlf.write("ADD_SUBDIRECTORY(${CMAKE_CURRENT_SOURCE_DIR}/../../../common ${CMAKE_CURRENT_BINARY_DIR}/common)\n")
+        cmlf.write("LINK_LIBRARIES(esd_core)\n")
     targets = []
     for suite in suites:
-        makefile, target = suite.build(**args)
-        makefiles.append(makefile)
+        srcfile, tfs, target, defines = suite.build(**args)
+        for path in tfs:
+            cmlf.write("# " + str(path) + "\n")
+        cmlf.write("ADD_EXECUTABLE(" + target + "\n")
+        cmlf.write("  " + srcfile + "\n")
+        for path in tfs:
+            if path:
+                sp.run([sys.executable, "../../dependencies/littlefs/scripts/explode_asserts.py", "-o", TEST_PATHS + '/' + target + ".toml." + path, TEST_PATHS + '/' + target + ".toml." + path.replace('.c', '.tc.tc')], check=True)
+                cmlf.write("  " + target + ".toml." + path + "\n")
+        for path in libfs:
+            if not path in tfs:
+                cmlf.write("  test." + path + "\n")
+        cmlf.write(")\n")
+        cmlf.write("TARGET_COMPILE_DEFINITIONS(" + target + " PUBLIC\n")
+        for k, v in sorted(defines.items()):
+            cmlf.write("  \"" + k + "=" + str(v) + "\"\n")
         targets.append(target)
+        cmlf.write(")\n")
+    cmlf.flush()
+    cmlf.close()
+
+    cwd = os.getcwd()
+    os.chdir(TEST_PATHS)
+    sp.run(["cmake", "-T", "ClangCl", "."], check=True)
+    sp.run(["cmake", "--build", ".", "-j" + str(os.cpu_count() * 3 // 4)], check=True)
+    os.chdir(cwd)
 
-    cmd = (['make', '-f', 'Makefile'] +
+    """
+    cmd = (['make', '-f', '../../dependencies/littlefs/Makefile'] +
         list(it.chain.from_iterable(['-f', m] for m in makefiles)) +
         [target for target in targets])
     mpty, spty = pty.openpty()
@@ -717,6 +1034,7 @@
             for line in stdout:
                 sys.stdout.write(line)
         sys.exit(-1)
+    """
 
     print('built %d test suites, %d test cases, %d permutations' % (
         len(suites),
@@ -856,5 +1174,9 @@
     parser.add_argument('--build-dir',
         help="Build relative to the specified directory instead of the \
             current directory.")
+    parser.add_argument('--eve-platform',
+        help="Build and run on the specified EVE platform.")
+    parser.add_argument('--eve-graphics',
+        help="Build and run for the specified EVE graphics chip.")
 
     sys.exit(main(**vars(parser.parse_args())))
