/*
 * Copyright (c) Bridgetek Pte Ltd
 *
 * THIS SOFTWARE IS PROVIDED BY BRIDGETEK PTE LTD "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * BRIDGETEK PTE LTD BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE, DATA, OR PROFITS OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * BRIDGETEK DRIVERS MAY BE USED ONLY IN CONJUNCTION WITH PRODUCTS BASED ON BRIDGETEK PARTS.
 *
 * BRIDGETEK DRIVERS MAY BE DISTRIBUTED IN ANY FORM AS LONG AS LICENSE INFORMATION IS NOT MODIFIED.
 *
 * IF A CUSTOM VENDOR ID AND/OR PRODUCT ID OR DESCRIPTION STRING ARE USED, IT IS THE
 * RESPONSIBILITY OF THE PRODUCT MANUFACTURER TO MAINTAIN ANY CHANGES AND SUBSEQUENT WHQL
 * RE-CERTIFICATION AS A RESULT OF MAKING THESE CHANGES.
 *
 * Abstract: Common functions for every Applications
 * Author : Bridgetek
 *
 * Revision History:
 * 1.0 - date 2019.09.30 - Initial for BT817
 */

#include "Common.h"
#include "Common.h"

char textbuffer[1000]; // for Draw_Text_Format
static uint32_t a, b, c, d, e, f;

uint32_t VertextFormat, VertextPrecision;

void Setup_Precision(format) {
	VertextFormat = format;

	switch (VertextFormat) {
	case 0:
		VertextPrecision = 1; break;
	case 1:
		VertextPrecision = 2; break;
	case 2:
		VertextPrecision = 4; break;
	case 3:
		VertextPrecision = 8; break;
	case 4:
		VertextPrecision = 16; break;
	default:
		VertextPrecision = 16; break;
	}
}

/**
 * cbCmdWait
 * EVE_Callback Callback function 
 */
bool cbCmdWait(struct EVE_HalContext *phost){
	return true;
}

/**
* Init_CapacitiveTouch
* Capacitive Touch initialzation
*/
void Init_CapacitiveTouch(EVE_HalContext *phost) {
#if defined(EVE_SUPPORT_CAPACITIVE)
	#define RAM_JTBOOT           3190784UL
	char touch_capcs_815[] = { 0xD7, 0x02, 0xD8, 0x02, 0x00, 0x80, 0x8C, 0x66, 0x01, 0x80, 0x8F, 0x62, 0x27, 0x61, 0x10, 0x61, 0x1D, 0x6B, 0x9C, 0x61, 0x00, 0x80, 0x8F, 0x67, 0x10, 0x61, 0x9D, 0x61, 0x11, 0x61, 0x9D, 0x61, 0x27, 0x61, 0x8C, 0x60, 0x27, 0x61, 0x11, 0x61, 0x1D, 0x6B, 0x9C, 0x61, 0x27, 0x61, 0x27, 0x61, 0x11, 0x61, 0x11, 0x61, 0x1D, 0x6B, 0x1D, 0x6B, 0x27, 0x61, 0x10, 0x61, 0x27, 0x61, 0x10, 0x61, 0x1D, 0x6B, 0x1D, 0x6B, 0x10, 0x61, 0x27, 0x61, 0x10, 0x61, 0x1D, 0x6B, 0x8C, 0x60, 0x03, 0x67, 0x8C, 0x66, 0x0A, 0x40, 0x8C, 0x66, 0x00, 0x80, 0x8F, 0x68, 0x10, 0x61, 0x8F, 0x68, 0x03, 0x68, 0x8C, 0x66, 0x10, 0x61, 0x8F, 0x6F, 0x00, 0x6A, 0x8C, 0x66, 0x33, 0x40, 0x8F, 0x62, 0x0E, 0x40, 0x03, 0x68, 0x3C, 0x20, 0x03, 0x61, 0x3D, 0x00, 0x8F, 0x60, 0x8C, 0x60, 0x0E, 0x40, 0x2D, 0x40, 0x39, 0x00, 0x11, 0x60, 0x8F, 0x62, 0x01, 0x80, 0x8F, 0x69, 0x00, 0x6A, 0x00, 0x80, 0x8C, 0x67, 0x27, 0x80, 0x01, 0x80, 0x10, 0x61, 0x33, 0x60, 0x8F, 0x61, 0x00, 0x80, 0x4A, 0x00, 0x11, 0x6C, 0x10, 0x61, 0x04, 0x40, 0x8C, 0x6C, 0x06, 0x40, 0x0B, 0x80, 0x4B, 0x40, 0x4B, 0x00, 0x4F, 0x40, 0x10, 0x61, 0x27, 0x61, 0x03, 0x62, 0x10, 0x61, 0x11, 0x6B, 0x03, 0x62, 0x10, 0x61, 0x11, 0x61, 0x1D, 0x6B, 0x03, 0x6F, 0x35, 0x00, 0x4F, 0x40, 0x06, 0x40, 0x27, 0x61, 0x00, 0x80, 0x00, 0x80, 0x1D, 0x6B, 0x11, 0x60, 0x78, 0x20, 0x24, 0x60, 0x01, 0x80, 0x03, 0x63, 0x71, 0x20, 0x16, 0x40, 0x58, 0x40, 0x1C, 0x40, 0x0E, 0x40, 0x58, 0x40, 0x1C, 0x40, 0x1D, 0x6B, 0x43, 0x40, 0x69, 0x00, 0x03, 0x61, 0x1C, 0x40, 0x03, 0x61, 0x8F, 0x61, 0x0E, 0x40, 0x14, 0x80, 0x63, 0x40, 0x27, 0x61, 0x27, 0x61, 0x12, 0x80, 0x63, 0x40, 0x1D, 0x6B, 0x1D, 0x6B, 0x58, 0x40, 0x16, 0x80, 0x57, 0x40, 0x03, 0x60, 0x22, 0x40, 0x1A, 0x80, 0x63, 0x40, 0x27, 0x61, 0x27, 0x61, 0x18, 0x80, 0x63, 0x40, 0x1D, 0x6B, 0x1D, 0x6B, 0x58, 0x40, 0x1C, 0x80, 0x57, 0x40, 0x8F, 0x60, 0x01, 0x80, 0x10, 0x61, 0x09, 0x80, 0x00, 0x6C, 0x10, 0x61, 0x03, 0x69, 0x8F, 0x63, 0x0C, 0x80, 0x00, 0x6C, 0x8F, 0x67, 0x00, 0x80, 0x9D, 0x40, 0x00, 0x66, 0xA0, 0x20, 0x8C, 0x60, 0x00, 0x80, 0x0A, 0x80, 0x11, 0x6C, 0xA7, 0x20, 0x33, 0x60, 0x8F, 0x61, 0x11, 0x60, 0xB4, 0x20, 0x40, 0x86, 0xA5, 0x40, 0x45, 0x40, 0xAE, 0x20, 0x03, 0x61, 0x00, 0x6A, 0xAB, 0x00, 0x8F, 0x61, 0xA5, 0x40, 0xA5, 0x00, 0x2C, 0x80, 0x49, 0x00, 0x2B, 0x80, 0x4D, 0x40, 0x01, 0x80, 0x2A, 0x80, 0x33, 0x60, 0x03, 0x61, 0x2A, 0x80, 0x11, 0x6C, 0x0A, 0x40, 0xC5, 0x20, 0xA5, 0x40, 0xC0, 0x00, 0x8F, 0x61, 0x01, 0x80, 0x2B, 0x80, 0x33, 0x60, 0x8F, 0x61, 0x2B, 0x80, 0x49, 0x40, 0xBB, 0x00, 0x2B, 0x80, 0x4D, 0x40, 0x00, 0x80, 0x2A, 0x80, 0x33, 0x60, 0x8F, 0x61, 0x2B, 0x80, 0x49, 0x40, 0xCF, 0x00, 0xCF, 0x40, 0xA5, 0x00, 0xCA, 0x40, 0xB5, 0x40, 0xB9, 0x40, 0xB5, 0x40, 0xCD, 0x00, 0xD3, 0x40, 0xB5, 0x40, 0xCD, 0x40, 0xB5, 0x40, 0xB9, 0x40, 0xB5, 0x40, 0xCA, 0x00, 0xC6, 0x40, 0xA5, 0x40, 0xBB, 0x40, 0x2A, 0x80, 0x11, 0x6C, 0xE8, 0x20, 0x03, 0x61, 0x2B, 0x80, 0xB5, 0x40, 0x00, 0x6C, 0xD6, 0x00, 0xCF, 0x40, 0x2B, 0x80, 0x33, 0x60, 0x03, 0x61, 0xA5, 0x40, 0xBB, 0x40, 0xB5, 0x40, 0xD6, 0x00, 0x7F, 0x80, 0x04, 0x80, 0x98, 0x00, 0x00, 0x80, 0xF7, 0x40, 0x41, 0x40, 0x03, 0x64, 0xD8, 0x40, 0xCF, 0x40, 0xB5, 0x40, 0x11, 0x60, 0x07, 0x80, 0x03, 0x69, 0xEF, 0x40, 0x11, 0x60, 0x06, 0x80, 0x03, 0x69, 0xEF, 0x40, 0x11, 0x60, 0x05, 0x80, 0x03, 0x69, 0xEF, 0x40, 0x11, 0x60, 0x04, 0x80, 0x03, 0x69, 0xEF, 0x40, 0x11, 0x60, 0x03, 0x80, 0x03, 0x69, 0xEF, 0x40, 0x11, 0x60, 0x02, 0x80, 0x03, 0x69, 0xEF, 0x40, 0x11, 0x60, 0x01, 0x80, 0x03, 0x69, 0xEF, 0x40, 0xEF, 0x40, 0xE4, 0x40, 0x21, 0x21, 0x00, 0x00, 0x8C, 0x60, 0x41, 0x40, 0xE4, 0x40, 0x8F, 0x62, 0xE4, 0x40, 0x22, 0x41, 0x22, 0x41, 0x22, 0x41, 0x22, 0x41, 0x22, 0x41, 0x22, 0x41, 0x22, 0x01, 0x01, 0x80, 0xFB, 0x40, 0x25, 0x41, 0x00, 0x80, 0xEF, 0x00, 0x02, 0x40, 0xEF, 0x00, 0x25, 0x41, 0x30, 0x01, 0x34, 0x41, 0x22, 0x41, 0x22, 0x41, 0x22, 0x41, 0x22, 0x41, 0x22, 0x41, 0x22, 0x41, 0x22, 0x41, 0x22, 0x41, 0x30, 0x01, 0x25, 0x41, 0x32, 0x41, 0x03, 0x61, 0xDD, 0x00, 0x22, 0x80, 0x53, 0x00, 0x20, 0x80, 0x53, 0x00, 0x24, 0x80, 0x53, 0x00, 0x21, 0x80, 0x4B, 0x40, 0x44, 0x41, 0x0E, 0x40, 0x46, 0x41, 0x23, 0x80, 0x53, 0x00, 0x1D, 0x6B, 0x03, 0x62, 0x27, 0x61, 0x8C, 0x60, 0xFF, 0xFF, 0x00, 0x66, 0x9D, 0x60, 0x55, 0x41, 0x06, 0x40, 0x04, 0x80, 0x37, 0x40, 0x51, 0x41, 0x44, 0x01, 0x46, 0x01, 0x4F, 0x01, 0x48, 0x01, 0x21, 0x80, 0x4B, 0x40, 0x25, 0x80, 0x4B, 0x00, 0x05, 0x80, 0x11, 0x60, 0x00, 0x6A, 0x58, 0x41, 0x45, 0x40, 0x66, 0x21, 0x8C, 0x60, 0x11, 0x60, 0x05, 0x80, 0x03, 0x6F, 0x75, 0x21, 0x01, 0x80, 0x10, 0x61, 0x03, 0x71, 0x03, 0x64, 0x76, 0x01, 0x8F, 0x61, 0x8C, 0x60, 0x27, 0x61, 0x00, 0x80, 0x10, 0x61, 0x11, 0x60, 0x82, 0x21, 0x10, 0x61, 0x11, 0x6B, 0x10, 0x40, 0x10, 0x61, 0x00, 0x6A, 0x7A, 0x01, 0xB5, 0x40, 0x40, 0x41, 0x03, 0x61, 0x0C, 0x60, 0x11, 0x60, 0x00, 0x80, 0x11, 0x60, 0x05, 0x80, 0x03, 0x68, 0x98, 0x21, 0x27, 0x61, 0x11, 0x60, 0x01, 0x80, 0x03, 0x63, 0x0A, 0x40, 0x94, 0x21, 0x11, 0x6B, 0x58, 0x41, 0x43, 0x40, 0x1D, 0x6B, 0x04, 0x40, 0x88, 0x01, 0x7A, 0x00, 0x03, 0x80, 0x96, 0x40, 0x0A, 0x00, 0xF7, 0x40, 0x5D, 0x80, 0x8F, 0x67, 0x4E, 0x81, 0xFA, 0x40, 0x9C, 0x41, 0xA8, 0x21, 0x08, 0x80, 0x00, 0x69, 0x80, 0x80, 0x03, 0x64, 0x01, 0x41, 0x01, 0x01, 0x00, 0x80, 0x0E, 0x80, 0x9E, 0x00, 0xA9, 0x41, 0x8C, 0x66, 0xB5, 0x40, 0x11, 0x61, 0x10, 0x40, 0x00, 0x80, 0x9D, 0x40, 0x03, 0x64, 0xB6, 0x21, 0x01, 0x00, 0x2D, 0x80, 0x00, 0x6C, 0x00, 0x67, 0xAF, 0x21, 0x7A, 0x00, 0xAC, 0x81, 0x9C, 0x41, 0xC4, 0x21, 0x4D, 0x80, 0xA0, 0x41, 0xDD, 0x40, 0x2D, 0x41, 0x40, 0x41, 0xC5, 0x01, 0x99, 0x41, 0x01, 0x80, 0x03, 0x63, 0x0E, 0x40, 0xAE, 0x41, 0x01, 0x80, 0x03, 0x65, 0xAE, 0x01, 0xA9, 0x81, 0xBC, 0x01, 0x36, 0x41, 0xFF, 0x8F, 0x8F, 0x63, 0xCE, 0x41, 0x36, 0x41, 0x0C, 0x80, 0x00, 0x69, 0x27, 0x61, 0xCF, 0x41, 0x36, 0x41, 0x03, 0x61, 0x7C, 0x40, 0x11, 0x6B, 0x5A, 0x41, 0x1D, 0x6B, 0x6C, 0x01, 0xFA, 0x40, 0x02, 0x80, 0x01, 0x41, 0xDD, 0x40, 0x2D, 0x01, 0xDE, 0x41, 0xD1, 0x81, 0x77, 0x41, 0x8F, 0x61, 0x02, 0x40, 0x02, 0x40, 0x55, 0x41, 0xFF, 0xFF, 0x8C, 0x60, 0xDE, 0x41, 0xCE, 0x41, 0xCE, 0x41, 0x06, 0x40, 0xF5, 0x21, 0x0E, 0x40, 0x7C, 0x40, 0xC8, 0x80, 0xF7, 0x01, 0x7A, 0x40, 0xE7, 0x41, 0xB5, 0x40, 0x40, 0x41, 0x4A, 0x01, 0xBB, 0x41, 0xE3, 0x41, 0x48, 0x40, 0xFA, 0x01, 0xCC, 0x41, 0xEC, 0x41, 0x48, 0x40, 0xFE, 0x01, 0x34, 0x41, 0x34, 0x41, 0x08, 0x80, 0x03, 0x71, 0x8F, 0x62, 0x9F, 0x41, 0xDD, 0x40, 0x2D, 0x41, 0x0F, 0x80, 0x8F, 0x63, 0x07, 0x42, 0x34, 0x41, 0x03, 0x61, 0x02, 0x42, 0x02, 0x42, 0xEF, 0x41, 0x9F, 0x41, 0x00, 0x80, 0x01, 0x41, 0xDD, 0x00, 0xCC, 0x41, 0x0C, 0x42, 0x48, 0x40, 0x16, 0x02, 0x34, 0x41, 0x27, 0x61, 0x02, 0x42, 0x02, 0x42, 0x34, 0x41, 0x03, 0x61, 0xD7, 0x01, 0x07, 0x42, 0x1A, 0x82, 0x77, 0x41, 0x12, 0x02, 0x00, 0x80, 0xBB, 0x41, 0x21, 0x42, 0x0C, 0x40, 0x03, 0x64, 0x2C, 0x22, 0x48, 0x40, 0x26, 0x02, 0x27, 0x61, 0x11, 0x6B, 0x00, 0x6C, 0x11, 0x67, 0x34, 0x22, 0x03, 0x61, 0x2E, 0x02, 0x0C, 0x60, 0x8F, 0x60, 0x11, 0x64, 0x2B, 0x00, 0x01, 0x80, 0x11, 0x61, 0x8F, 0x71, 0x00, 0x80, 0x11, 0x60, 0x05, 0x80, 0x03, 0x68, 0x4C, 0x22, 0x27, 0x61, 0x11, 0x60, 0x01, 0x80, 0x03, 0x63, 0x0A, 0x40, 0x48, 0x22, 0x11, 0x6B, 0x58, 0x41, 0x43, 0x40, 0x1D, 0x6B, 0x04, 0x40, 0x3C, 0x02, 0x7A, 0x00, 0xAC, 0x41, 0x52, 0x22, 0xE7, 0x41, 0x4A, 0x41, 0x53, 0x02, 0x65, 0x41, 0x29, 0x80, 0x49, 0x40, 0x0F, 0x80, 0x10, 0x80, 0x00, 0x6C, 0x11, 0x67, 0x5C, 0x22, 0x03, 0x61, 0x56, 0x02, 0x0F, 0x80, 0x00, 0x65, 0x68, 0x22, 0x0D, 0x80, 0x00, 0x6C, 0x11, 0x80, 0x00, 0x6C, 0x27, 0x61, 0x27, 0x61, 0x29, 0x80, 0x4D, 0x40, 0x56, 0x02, 0x03, 0x61, 0xAC, 0x41, 0x76, 0x22, 0x1D, 0x6B, 0x1D, 0x6B, 0x36, 0x42, 0x71, 0x22, 0xE7, 0x41, 0x74, 0x02, 0x0E, 0x40, 0x7C, 0x40, 0xC8, 0x80, 0x4A, 0x41, 0x8D, 0x02, 0x00, 0x80, 0x10, 0x61, 0x0F, 0x80, 0x00, 0x65, 0x8B, 0x22, 0x38, 0x42, 0x06, 0x40, 0x03, 0x64, 0x10, 0x61, 0x1D, 0x6B, 0x1D, 0x6B, 0x36, 0x42, 0x86, 0x22, 0x7A, 0x40, 0x55, 0x41, 0x87, 0x02, 0x7C, 0x40, 0x06, 0x40, 0x5A, 0x41, 0x10, 0x61, 0x78, 0x02, 0x03, 0x61, 0x3B, 0x42, 0x48, 0x40, 0x53, 0x02, 0x8C, 0x60, 0x0B, 0x80, 0x96, 0x40, 0xA0, 0x20, 0xFA, 0x40, 0x99, 0x41, 0x98, 0x22, 0x03, 0x80, 0xA5, 0x80, 0x01, 0x41, 0x01, 0x41, 0xDD, 0x40, 0xA0, 0x40, 0x00, 0x00, 0x2C, 0x80, 0x4D, 0x40, 0xAB, 0x40, 0xB7, 0x40, 0xAB, 0x00, 0x0E, 0x80, 0x96, 0x40, 0xA6, 0x22, 0x4D, 0x42, 0xB7, 0x40, 0xAC, 0x41, 0x11, 0x60, 0xAD, 0x22, 0xE7, 0x41, 0x4A, 0x41, 0xAE, 0x02, 0x65, 0x41, 0x48, 0x40, 0x02, 0x80, 0x9A, 0x41, 0xC2, 0x22, 0x9C, 0x41, 0xBF, 0x22, 0x01, 0x80, 0x04, 0x80, 0x4B, 0x40, 0x37, 0x80, 0x01, 0x80, 0x9D, 0x42, 0x04, 0x80, 0x4D, 0x40, 0x50, 0x80, 0xAB, 0x40, 0xC2, 0x02, 0x2C, 0x81, 0x06, 0x80, 0x9D, 0x42, 0xAC, 0x41, 0x27, 0x40, 0x1F, 0x41, 0x01, 0x80, 0xAB, 0x00, 0x00, 0x80, 0x9D, 0x40, 0xCB, 0x22, 0x90, 0x42, 0x9C, 0x41, 0xD0, 0x22, 0xAC, 0x41, 0x25, 0x22, 0x16, 0x42, 0xAC, 0x41, 0xFA, 0x21, 0xFE, 0x41, 0xFA, 0x40, 0xA1, 0x41, 0x01, 0x41, 0xDD, 0x00, 0xA2, 0x42, 0xC7, 0x02 };
	EVE_sleep(1000);

	EVE_Hal_wr8(phost, REG_CPURESET, 2);
	EVE_Hal_wrMem(phost, RAM_JTBOOT, touch_capcs_815, sizeof(touch_capcs_815));
	EVE_Hal_wr8(phost, REG_CPURESET, 0);
#endif
}
/**
* Gpu_Init
* EVE initialzation
 */
void Gpu_Init(EVE_HalContext *phost, Ft_Gpu_HalInit_t *halInit) {
	EVE_HalPlatform *platform = EVE_Hal_initialize();
	halInit->TotalChannelNum = EVE_Hal_list();

	EVE_HalParameters params;
	EVE_Hal_defaults(&params);

	params.CbCmdWait = cbCmdWait;

#ifdef BT8XXEMU_PLATFORM
	BT8XXEMU_EmulatorParameters emulatorParams;
	BT8XXEMU_FlashParameters flashParams;
	BT8XXEMU_defaults(BT8XXEMU_VERSION_API, &emulatorParams, EVE_CHIPID);
	emulatorParams.Flags &= (~BT8XXEMU_EmulatorEnableDynamicDegrade);
	params.EmulatorParameters = &emulatorParams;

	BT8XXEMU_Flash_defaults(BT8XXEMU_VERSION_API, &flashParams);
	flashParams.SizeBytes = 16 * 1024 * 1024;
	wcscpy(flashParams.DataFilePath, L"__Flash.bin");
	params.EmulatorFlashParameters = &flashParams;
#endif

	EVE_Hal_open(phost, &params); /* TODO: Handle result */

	EVE_Util_bootupConfig(phost);

#ifdef DISPLAY_RESOLUTION_WXGA
	EVE_Hal_wr8(phost, REG_ADAPTIVE_FRAMERATE, 0);
	EVE_Hal_wr8(phost, REG_CPURESET, 2);
	EVE_Hal_wr16(phost, REG_TOUCH_CONFIG, 0x05D0);	//for Goodix touch panel
	EVE_Hal_wr8(phost, REG_CPURESET, 0);
	EVE_sleep(300);
#endif

#if defined(BT817_ENABLE) || defined(BT818_ENABLE)
	/// Enable capacity touch
	Init_CapacitiveTouch(phost);

	/// set API level to BT817
	EVE_CoCmd_apiLevel(phost, 2);
	EVE_Cmd_waitFlush(phost);
	printf("Set APILEVEL to BT817/8 (2)\n");
#else
	printf("Set APILEVEL to default (1)\n");
#endif

#if defined(FT900_PLATFORM) || defined(FT93X_PLATFORM)
	EVE_Util_loadSdCard(phost);
#endif

	// Precision control
	Setup_Precision(4); // Default vertext format = 4
}

void Gpu_Release(EVE_HalContext *phost) {
	EVE_Hal_close(phost);
	EVE_Hal_release();
}

/**
*  Get_SystemClock
* 	Get system frequency in Hz
*/
uint32_t  Get_SystemClock(EVE_HalContext *phost) {
	EVE_Hal_rd32(phost, REG_CLOCK);// warm up

	uint32_t c0 = EVE_Hal_rd32(phost, REG_CLOCK);
	uint32_t c1 = EVE_Hal_rd32(phost, REG_CLOCK);

	uint32_t overhead = c1 - c0;

	c0 = EVE_Hal_rd32(phost, REG_CLOCK);
	EVE_sleep(1000);
	c1 = EVE_Hal_rd32(phost, REG_CLOCK);

	uint32_t freq = round((c1 - c0) - overhead);

	return freq;
}

uint32_t Draw_Point(EVE_HalContext *phost, uint32_t Rx, uint32_t Ry, uint32_t R) {
	EVE_Cmd_wr32(phost, POINT_SIZE(VP(R)));
	EVE_Cmd_wr32(phost, BEGIN(POINTS));
	EVE_Cmd_wr32(phost, VERTEX2F(VP(Rx ), VP(Ry )));
}

uint32_t Draw_Image(EVE_HalContext *phost, char *filePath, uint32_t format) {
#if defined(BT817_ENABLE) || defined(BT818_ENABLE)
	Gpu_Hal_LoadImageToMemory(phost, filePath, RAM_G, LOADIMAGE);
	uint32_t ptr, w, h;
	EVE_CoCmd_getProps(phost, &ptr, &w, &h);
	Display_End(phost);

	EVE_CoCmd_dlStart(phost);
	EVE_Cmd_wr32(phost, CLEAR(1, 1, 1));
	EVE_Cmd_wr32(phost, COLOR_RGB(255, 255, 255));
	EVE_Cmd_wr32(phost, COLOR_RGB(255, 255, 255));

	EVE_Cmd_waitFlush(phost);
	EVE_CoCmd_setBitmap(phost, RAM_G, format, w, h);

	//Start drawing bitmap
	EVE_Cmd_wr32(phost, BEGIN(BITMAPS));
	EVE_Cmd_wr32(phost, VERTEX2II(0, 0, 0, 0));
	EVE_Cmd_wr32(phost, END());
	EVE_Cmd_wr32(phost, RESTORE_CONTEXT());
	EVE_Cmd_wr32(phost, DISPLAY());
	EVE_CoCmd_swap(phost);
	EVE_Cmd_waitFlush(phost);
#endif
}

void Calibration_Restore(EVE_HalContext *phost) {
	EVE_Hal_wr32(phost, REG_TOUCH_TRANSFORM_A, a);
	EVE_Hal_wr32(phost, REG_TOUCH_TRANSFORM_B, b);
	EVE_Hal_wr32(phost, REG_TOUCH_TRANSFORM_C, c);
	EVE_Hal_wr32(phost, REG_TOUCH_TRANSFORM_D, d);
	EVE_Hal_wr32(phost, REG_TOUCH_TRANSFORM_E, e);
	EVE_Hal_wr32(phost, REG_TOUCH_TRANSFORM_F, f);
}

void Calibration_Save(EVE_HalContext *phost) {
	a = EVE_Hal_rd32(phost, REG_TOUCH_TRANSFORM_A);
	b = EVE_Hal_rd32(phost, REG_TOUCH_TRANSFORM_B);
	c = EVE_Hal_rd32(phost, REG_TOUCH_TRANSFORM_C);
	d = EVE_Hal_rd32(phost, REG_TOUCH_TRANSFORM_D);
	e = EVE_Hal_rd32(phost, REG_TOUCH_TRANSFORM_E);
	f = EVE_Hal_rd32(phost, REG_TOUCH_TRANSFORM_F);
}

void Display_Start(EVE_HalContext *phost) {
	EVE_CoCmd_dlStart(phost);
	EVE_Cmd_wr32(phost, CLEAR_COLOR_RGB(255, 255, 255));
	EVE_Cmd_wr32(phost, CLEAR(1, 1, 1));
	EVE_Cmd_wr32(phost, COLOR_RGB(255, 255, 255));
	EVE_Cmd_wr32(phost, VERTEX_FORMAT(VertextFormat));
}

void Display_End(EVE_HalContext *phost) {
	EVE_Cmd_wr32(phost, DISPLAY());
	EVE_CoCmd_swap(phost);
	EVE_Cmd_waitFlush(phost);
}

static void Gpu_Text(EVE_HalContext* phost, char8_t* str) {
	uint32_t font = 0;

	if (DispWidth == 480) {
		font = 28;
	}
	else if (DispWidth == 800) {
		font = 30;
	}
	else {
		font = 27;
	}

	Display_Start(phost);
	EVE_Cmd_wr32(phost, COLOR_RGB(0, 0, 0));
	EVE_CoCmd_fillWidth(phost, DispWidth);
	EVE_CoCmd_text(phost, (DispWidth / 2), DispHeight / 2, font, OPT_CENTERX | OPT_FILL, str);
	Display_End(phost);
}

void Draw_Text(EVE_HalContext *phost, char8_t *str) {
	Gpu_Text(phost, str);
	EVE_sleep(2000);
}

void Draw_Text2(EVE_HalContext *phost, char8_t *str, int ms) {
	Gpu_Text(phost, str);
	EVE_sleep(ms);
}

void Play_MuteSound(EVE_HalContext *phost) {
	EVE_Hal_wr16(phost, REG_SOUND, 0x0060);
	EVE_Hal_wr8(phost, REG_PLAY, 0x01);
}

void Get_VC1Dump(EVE_HalContext *phost, char *filename) {
#if defined(MSVC_PLATFORM) || defined(MSVC_FT800EMU)
	FILE *vc1dump = fopen(filename, "wb");
	const int32_t blockSize = 64 * 1024;

	if (!vc1dump) {
		APP_ERR("Cannot open file %s", filename);
		return;
	}

	const uint32_t VERSION = 110;
	const uint32_t WIDTH = DispWidth, HEIGHT = DispHeight;
	const uint32_t macro0 = 0;
	const uint32_t macro1 = 0;
	const uint32_t CRC_IMAGE = 0;

	fwrite(&VERSION, 4, 1, vc1dump);
	fwrite(&WIDTH, 4, 1, vc1dump);
	fwrite(&HEIGHT, 4, 1, vc1dump);
	fwrite(&macro0, 4, 1, vc1dump);
	fwrite(&macro1, 4, 1, vc1dump);
	fwrite(&CRC_IMAGE, 4, 1, vc1dump);

	uint8_t *buffer = malloc(RAM_G_SIZE);
	if (!buffer) {
		APP_ERR("Malloc failed");
		fclose(vc1dump);
		return;
	}

	memset(buffer, 0, sizeof(buffer));
	EVE_Hal_rdMem(phost, buffer, RAM_G, RAM_G_SIZE);
	fwrite(buffer, 1, RAM_G_SIZE, vc1dump);

	memset(buffer, 0, sizeof(buffer));
	EVE_Hal_rdMem(phost, buffer, RAM_DL, EVE_DL_SIZE);
	fwrite(buffer, 1, EVE_DL_SIZE, vc1dump);

	fclose(vc1dump);
	free(buffer);
#endif
}

void Play_Sound(EVE_HalContext *phost, uint8_t sound, uint8_t vol, uint8_t midi)
{
	uint16_t val = (midi << 8) | sound;
	EVE_Hal_wr8(phost, REG_VOL_SOUND, vol);
	EVE_Hal_wr16(phost, REG_SOUND, val);
	EVE_Hal_wr8(phost, REG_PLAY, 1);
}

