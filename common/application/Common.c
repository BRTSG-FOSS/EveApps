/*
 * Copyright (c) Bridgetek Pte Ltd
 *
 * THIS SOFTWARE IS PROVIDED BY BRIDGETEK PTE LTD "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * BRIDGETEK PTE LTD BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE, DATA, OR PROFITS OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * BRIDGETEK DRIVERS MAY BE USED ONLY IN CONJUNCTION WITH PRODUCTS BASED ON BRIDGETEK PARTS.
 *
 * BRIDGETEK DRIVERS MAY BE DISTRIBUTED IN ANY FORM AS LONG AS LICENSE INFORMATION IS NOT MODIFIED.
 *
 * IF A CUSTOM VENDOR ID AND/OR PRODUCT ID OR DESCRIPTION STRING ARE USED, IT IS THE
 * RESPONSIBILITY OF THE PRODUCT MANUFACTURER TO MAINTAIN ANY CHANGES AND SUBSEQUENT WHQL
 * RE-CERTIFICATION AS A RESULT OF MAKING THESE CHANGES.
 *
 * Abstract: Common functions for every Applications
 * Author : Bridgetek
 *
 * Revision History:
 * 1.0 - date 2019.09.30 - Initial for BT817
 */

#include "Common.h"
#include <math.h>

char textbuffer[1000]; // for Draw_Text_Format
static uint32_t a;
static uint32_t b;
static uint32_t c;
static uint32_t d;
static uint32_t e;
static uint32_t f;

uint32_t VertextFormat;
uint32_t VertextPrecision;

void Setup_Precision(uint32_t format) {
	VertextFormat = format;

	switch (VertextFormat) {
	case 0:
		VertextPrecision = 1;
		break;
	case 1:
		VertextPrecision = 2;
		break;
	case 2:
		VertextPrecision = 4;
		break;
	case 3:
		VertextPrecision = 8;
		break;
	case 4:
		VertextPrecision = 16;
		break;
	default:
		VertextPrecision = 16;
		break;
	}
}

/**
 * cbCmdWait
 * EVE_Callback Callback function
 */
bool cbCmdWait(struct EVE_HalContext* phost) {
	(void) (phost); // suspress warning on unused
	return true;
}

/**
 * Init_CapacitiveTouch
 * Capacitive Touch initialzation
 */
void Init_CapacitiveTouch(EVE_HalContext* phost) {
#if defined(EVE_SUPPORT_CAPACITIVE)
	char touch_capcs_815[] = { 0xD7, 0x02, 0xD8, 0x02, 0x00, 0x80, 0x8C, 0x66,
			0x01, 0x80, 0x8F, 0x62, 0x27, 0x61, 0x10, 0x61, 0x1D, 0x6B, 0x9C,
			0x61, 0x00, 0x80, 0x8F, 0x67, 0x10, 0x61, 0x9D, 0x61, 0x11, 0x61,
			0x9D, 0x61, 0x27, 0x61, 0x8C, 0x60, 0x27, 0x61, 0x11, 0x61, 0x1D,
			0x6B, 0x9C, 0x61, 0x27, 0x61, 0x27, 0x61, 0x11, 0x61, 0x11, 0x61,
			0x1D, 0x6B, 0x1D, 0x6B, 0x27, 0x61, 0x10, 0x61, 0x27, 0x61, 0x10,
			0x61, 0x1D, 0x6B, 0x1D, 0x6B, 0x10, 0x61, 0x27, 0x61, 0x10, 0x61,
			0x1D, 0x6B, 0x8C, 0x60, 0x03, 0x67, 0x8C, 0x66, 0x0A, 0x40, 0x8C,
			0x66, 0x00, 0x80, 0x8F, 0x68, 0x10, 0x61, 0x8F, 0x68, 0x03, 0x68,
			0x8C, 0x66, 0x10, 0x61, 0x8F, 0x6F, 0x00, 0x6A, 0x8C, 0x66, 0x33,
			0x40, 0x8F, 0x62, 0x0E, 0x40, 0x03, 0x68, 0x3C, 0x20, 0x03, 0x61,
			0x3D, 0x00, 0x8F, 0x60, 0x8C, 0x60, 0x0E, 0x40, 0x2D, 0x40, 0x39,
			0x00, 0x11, 0x60, 0x8F, 0x62, 0x01, 0x80, 0x8F, 0x69, 0x00, 0x6A,
			0x00, 0x80, 0x8C, 0x67, 0x27, 0x80, 0x01, 0x80, 0x10, 0x61, 0x33,
			0x60, 0x8F, 0x61, 0x00, 0x80, 0x4A, 0x00, 0x11, 0x6C, 0x10, 0x61,
			0x04, 0x40, 0x8C, 0x6C, 0x06, 0x40, 0x0B, 0x80, 0x4B, 0x40, 0x4B,
			0x00, 0x4F, 0x40, 0x10, 0x61, 0x27, 0x61, 0x03, 0x62, 0x10, 0x61,
			0x11, 0x6B, 0x03, 0x62, 0x10, 0x61, 0x11, 0x61, 0x1D, 0x6B, 0x03,
			0x6F, 0x35, 0x00, 0x4F, 0x40, 0x06, 0x40, 0x27, 0x61, 0x00, 0x80,
			0x00, 0x80, 0x1D, 0x6B, 0x11, 0x60, 0x78, 0x20, 0x24, 0x60, 0x01,
			0x80, 0x03, 0x63, 0x71, 0x20, 0x16, 0x40, 0x58, 0x40, 0x1C, 0x40,
			0x0E, 0x40, 0x58, 0x40, 0x1C, 0x40, 0x1D, 0x6B, 0x43, 0x40, 0x69,
			0x00, 0x03, 0x61, 0x1C, 0x40, 0x03, 0x61, 0x8F, 0x61, 0x0E, 0x40,
			0x14, 0x80, 0x63, 0x40, 0x27, 0x61, 0x27, 0x61, 0x12, 0x80, 0x63,
			0x40, 0x1D, 0x6B, 0x1D, 0x6B, 0x58, 0x40, 0x16, 0x80, 0x57, 0x40,
			0x03, 0x60, 0x22, 0x40, 0x1A, 0x80, 0x63, 0x40, 0x27, 0x61, 0x27,
			0x61, 0x18, 0x80, 0x63, 0x40, 0x1D, 0x6B, 0x1D, 0x6B, 0x58, 0x40,
			0x1C, 0x80, 0x57, 0x40, 0x8F, 0x60, 0x01, 0x80, 0x10, 0x61, 0x09,
			0x80, 0x00, 0x6C, 0x10, 0x61, 0x03, 0x69, 0x8F, 0x63, 0x0C, 0x80,
			0x00, 0x6C, 0x8F, 0x67, 0x00, 0x80, 0x9D, 0x40, 0x00, 0x66, 0xA0,
			0x20, 0x8C, 0x60, 0x00, 0x80, 0x0A, 0x80, 0x11, 0x6C, 0xA7, 0x20,
			0x33, 0x60, 0x8F, 0x61, 0x11, 0x60, 0xB4, 0x20, 0x40, 0x86, 0xA5,
			0x40, 0x45, 0x40, 0xAE, 0x20, 0x03, 0x61, 0x00, 0x6A, 0xAB, 0x00,
			0x8F, 0x61, 0xA5, 0x40, 0xA5, 0x00, 0x2C, 0x80, 0x49, 0x00, 0x2B,
			0x80, 0x4D, 0x40, 0x01, 0x80, 0x2A, 0x80, 0x33, 0x60, 0x03, 0x61,
			0x2A, 0x80, 0x11, 0x6C, 0x0A, 0x40, 0xC5, 0x20, 0xA5, 0x40, 0xC0,
			0x00, 0x8F, 0x61, 0x01, 0x80, 0x2B, 0x80, 0x33, 0x60, 0x8F, 0x61,
			0x2B, 0x80, 0x49, 0x40, 0xBB, 0x00, 0x2B, 0x80, 0x4D, 0x40, 0x00,
			0x80, 0x2A, 0x80, 0x33, 0x60, 0x8F, 0x61, 0x2B, 0x80, 0x49, 0x40,
			0xCF, 0x00, 0xCF, 0x40, 0xA5, 0x00, 0xCA, 0x40, 0xB5, 0x40, 0xB9,
			0x40, 0xB5, 0x40, 0xCD, 0x00, 0xD3, 0x40, 0xB5, 0x40, 0xCD, 0x40,
			0xB5, 0x40, 0xB9, 0x40, 0xB5, 0x40, 0xCA, 0x00, 0xC6, 0x40, 0xA5,
			0x40, 0xBB, 0x40, 0x2A, 0x80, 0x11, 0x6C, 0xE8, 0x20, 0x03, 0x61,
			0x2B, 0x80, 0xB5, 0x40, 0x00, 0x6C, 0xD6, 0x00, 0xCF, 0x40, 0x2B,
			0x80, 0x33, 0x60, 0x03, 0x61, 0xA5, 0x40, 0xBB, 0x40, 0xB5, 0x40,
			0xD6, 0x00, 0x7F, 0x80, 0x04, 0x80, 0x98, 0x00, 0x00, 0x80, 0xF7,
			0x40, 0x41, 0x40, 0x03, 0x64, 0xD8, 0x40, 0xCF, 0x40, 0xB5, 0x40,
			0x11, 0x60, 0x07, 0x80, 0x03, 0x69, 0xEF, 0x40, 0x11, 0x60, 0x06,
			0x80, 0x03, 0x69, 0xEF, 0x40, 0x11, 0x60, 0x05, 0x80, 0x03, 0x69,
			0xEF, 0x40, 0x11, 0x60, 0x04, 0x80, 0x03, 0x69, 0xEF, 0x40, 0x11,
			0x60, 0x03, 0x80, 0x03, 0x69, 0xEF, 0x40, 0x11, 0x60, 0x02, 0x80,
			0x03, 0x69, 0xEF, 0x40, 0x11, 0x60, 0x01, 0x80, 0x03, 0x69, 0xEF,
			0x40, 0xEF, 0x40, 0xE4, 0x40, 0x21, 0x21, 0x00, 0x00, 0x8C, 0x60,
			0x41, 0x40, 0xE4, 0x40, 0x8F, 0x62, 0xE4, 0x40, 0x22, 0x41, 0x22,
			0x41, 0x22, 0x41, 0x22, 0x41, 0x22, 0x41, 0x22, 0x41, 0x22, 0x01,
			0x01, 0x80, 0xFB, 0x40, 0x25, 0x41, 0x00, 0x80, 0xEF, 0x00, 0x02,
			0x40, 0xEF, 0x00, 0x25, 0x41, 0x30, 0x01, 0x34, 0x41, 0x22, 0x41,
			0x22, 0x41, 0x22, 0x41, 0x22, 0x41, 0x22, 0x41, 0x22, 0x41, 0x22,
			0x41, 0x22, 0x41, 0x30, 0x01, 0x25, 0x41, 0x32, 0x41, 0x03, 0x61,
			0xDD, 0x00, 0x22, 0x80, 0x53, 0x00, 0x20, 0x80, 0x53, 0x00, 0x24,
			0x80, 0x53, 0x00, 0x21, 0x80, 0x4B, 0x40, 0x44, 0x41, 0x0E, 0x40,
			0x46, 0x41, 0x23, 0x80, 0x53, 0x00, 0x1D, 0x6B, 0x03, 0x62, 0x27,
			0x61, 0x8C, 0x60, 0xFF, 0xFF, 0x00, 0x66, 0x9D, 0x60, 0x55, 0x41,
			0x06, 0x40, 0x04, 0x80, 0x37, 0x40, 0x51, 0x41, 0x44, 0x01, 0x46,
			0x01, 0x4F, 0x01, 0x48, 0x01, 0x21, 0x80, 0x4B, 0x40, 0x25, 0x80,
			0x4B, 0x00, 0x05, 0x80, 0x11, 0x60, 0x00, 0x6A, 0x58, 0x41, 0x45,
			0x40, 0x66, 0x21, 0x8C, 0x60, 0x11, 0x60, 0x05, 0x80, 0x03, 0x6F,
			0x75, 0x21, 0x01, 0x80, 0x10, 0x61, 0x03, 0x71, 0x03, 0x64, 0x76,
			0x01, 0x8F, 0x61, 0x8C, 0x60, 0x27, 0x61, 0x00, 0x80, 0x10, 0x61,
			0x11, 0x60, 0x82, 0x21, 0x10, 0x61, 0x11, 0x6B, 0x10, 0x40, 0x10,
			0x61, 0x00, 0x6A, 0x7A, 0x01, 0xB5, 0x40, 0x40, 0x41, 0x03, 0x61,
			0x0C, 0x60, 0x11, 0x60, 0x00, 0x80, 0x11, 0x60, 0x05, 0x80, 0x03,
			0x68, 0x98, 0x21, 0x27, 0x61, 0x11, 0x60, 0x01, 0x80, 0x03, 0x63,
			0x0A, 0x40, 0x94, 0x21, 0x11, 0x6B, 0x58, 0x41, 0x43, 0x40, 0x1D,
			0x6B, 0x04, 0x40, 0x88, 0x01, 0x7A, 0x00, 0x03, 0x80, 0x96, 0x40,
			0x0A, 0x00, 0xF7, 0x40, 0x5D, 0x80, 0x8F, 0x67, 0x4E, 0x81, 0xFA,
			0x40, 0x9C, 0x41, 0xA8, 0x21, 0x08, 0x80, 0x00, 0x69, 0x80, 0x80,
			0x03, 0x64, 0x01, 0x41, 0x01, 0x01, 0x00, 0x80, 0x0E, 0x80, 0x9E,
			0x00, 0xA9, 0x41, 0x8C, 0x66, 0xB5, 0x40, 0x11, 0x61, 0x10, 0x40,
			0x00, 0x80, 0x9D, 0x40, 0x03, 0x64, 0xB6, 0x21, 0x01, 0x00, 0x2D,
			0x80, 0x00, 0x6C, 0x00, 0x67, 0xAF, 0x21, 0x7A, 0x00, 0xAC, 0x81,
			0x9C, 0x41, 0xC4, 0x21, 0x4D, 0x80, 0xA0, 0x41, 0xDD, 0x40, 0x2D,
			0x41, 0x40, 0x41, 0xC5, 0x01, 0x99, 0x41, 0x01, 0x80, 0x03, 0x63,
			0x0E, 0x40, 0xAE, 0x41, 0x01, 0x80, 0x03, 0x65, 0xAE, 0x01, 0xA9,
			0x81, 0xBC, 0x01, 0x36, 0x41, 0xFF, 0x8F, 0x8F, 0x63, 0xCE, 0x41,
			0x36, 0x41, 0x0C, 0x80, 0x00, 0x69, 0x27, 0x61, 0xCF, 0x41, 0x36,
			0x41, 0x03, 0x61, 0x7C, 0x40, 0x11, 0x6B, 0x5A, 0x41, 0x1D, 0x6B,
			0x6C, 0x01, 0xFA, 0x40, 0x02, 0x80, 0x01, 0x41, 0xDD, 0x40, 0x2D,
			0x01, 0xDE, 0x41, 0xD1, 0x81, 0x77, 0x41, 0x8F, 0x61, 0x02, 0x40,
			0x02, 0x40, 0x55, 0x41, 0xFF, 0xFF, 0x8C, 0x60, 0xDE, 0x41, 0xCE,
			0x41, 0xCE, 0x41, 0x06, 0x40, 0xF5, 0x21, 0x0E, 0x40, 0x7C, 0x40,
			0xC8, 0x80, 0xF7, 0x01, 0x7A, 0x40, 0xE7, 0x41, 0xB5, 0x40, 0x40,
			0x41, 0x4A, 0x01, 0xBB, 0x41, 0xE3, 0x41, 0x48, 0x40, 0xFA, 0x01,
			0xCC, 0x41, 0xEC, 0x41, 0x48, 0x40, 0xFE, 0x01, 0x34, 0x41, 0x34,
			0x41, 0x08, 0x80, 0x03, 0x71, 0x8F, 0x62, 0x9F, 0x41, 0xDD, 0x40,
			0x2D, 0x41, 0x0F, 0x80, 0x8F, 0x63, 0x07, 0x42, 0x34, 0x41, 0x03,
			0x61, 0x02, 0x42, 0x02, 0x42, 0xEF, 0x41, 0x9F, 0x41, 0x00, 0x80,
			0x01, 0x41, 0xDD, 0x00, 0xCC, 0x41, 0x0C, 0x42, 0x48, 0x40, 0x16,
			0x02, 0x34, 0x41, 0x27, 0x61, 0x02, 0x42, 0x02, 0x42, 0x34, 0x41,
			0x03, 0x61, 0xD7, 0x01, 0x07, 0x42, 0x1A, 0x82, 0x77, 0x41, 0x12,
			0x02, 0x00, 0x80, 0xBB, 0x41, 0x21, 0x42, 0x0C, 0x40, 0x03, 0x64,
			0x2C, 0x22, 0x48, 0x40, 0x26, 0x02, 0x27, 0x61, 0x11, 0x6B, 0x00,
			0x6C, 0x11, 0x67, 0x34, 0x22, 0x03, 0x61, 0x2E, 0x02, 0x0C, 0x60,
			0x8F, 0x60, 0x11, 0x64, 0x2B, 0x00, 0x01, 0x80, 0x11, 0x61, 0x8F,
			0x71, 0x00, 0x80, 0x11, 0x60, 0x05, 0x80, 0x03, 0x68, 0x4C, 0x22,
			0x27, 0x61, 0x11, 0x60, 0x01, 0x80, 0x03, 0x63, 0x0A, 0x40, 0x48,
			0x22, 0x11, 0x6B, 0x58, 0x41, 0x43, 0x40, 0x1D, 0x6B, 0x04, 0x40,
			0x3C, 0x02, 0x7A, 0x00, 0xAC, 0x41, 0x52, 0x22, 0xE7, 0x41, 0x4A,
			0x41, 0x53, 0x02, 0x65, 0x41, 0x29, 0x80, 0x49, 0x40, 0x0F, 0x80,
			0x10, 0x80, 0x00, 0x6C, 0x11, 0x67, 0x5C, 0x22, 0x03, 0x61, 0x56,
			0x02, 0x0F, 0x80, 0x00, 0x65, 0x68, 0x22, 0x0D, 0x80, 0x00, 0x6C,
			0x11, 0x80, 0x00, 0x6C, 0x27, 0x61, 0x27, 0x61, 0x29, 0x80, 0x4D,
			0x40, 0x56, 0x02, 0x03, 0x61, 0xAC, 0x41, 0x76, 0x22, 0x1D, 0x6B,
			0x1D, 0x6B, 0x36, 0x42, 0x71, 0x22, 0xE7, 0x41, 0x74, 0x02, 0x0E,
			0x40, 0x7C, 0x40, 0xC8, 0x80, 0x4A, 0x41, 0x8D, 0x02, 0x00, 0x80,
			0x10, 0x61, 0x0F, 0x80, 0x00, 0x65, 0x8B, 0x22, 0x38, 0x42, 0x06,
			0x40, 0x03, 0x64, 0x10, 0x61, 0x1D, 0x6B, 0x1D, 0x6B, 0x36, 0x42,
			0x86, 0x22, 0x7A, 0x40, 0x55, 0x41, 0x87, 0x02, 0x7C, 0x40, 0x06,
			0x40, 0x5A, 0x41, 0x10, 0x61, 0x78, 0x02, 0x03, 0x61, 0x3B, 0x42,
			0x48, 0x40, 0x53, 0x02, 0x8C, 0x60, 0x0B, 0x80, 0x96, 0x40, 0xA0,
			0x20, 0xFA, 0x40, 0x99, 0x41, 0x98, 0x22, 0x03, 0x80, 0xA5, 0x80,
			0x01, 0x41, 0x01, 0x41, 0xDD, 0x40, 0xA0, 0x40, 0x00, 0x00, 0x2C,
			0x80, 0x4D, 0x40, 0xAB, 0x40, 0xB7, 0x40, 0xAB, 0x00, 0x0E, 0x80,
			0x96, 0x40, 0xA6, 0x22, 0x4D, 0x42, 0xB7, 0x40, 0xAC, 0x41, 0x11,
			0x60, 0xAD, 0x22, 0xE7, 0x41, 0x4A, 0x41, 0xAE, 0x02, 0x65, 0x41,
			0x48, 0x40, 0x02, 0x80, 0x9A, 0x41, 0xC2, 0x22, 0x9C, 0x41, 0xBF,
			0x22, 0x01, 0x80, 0x04, 0x80, 0x4B, 0x40, 0x37, 0x80, 0x01, 0x80,
			0x9D, 0x42, 0x04, 0x80, 0x4D, 0x40, 0x50, 0x80, 0xAB, 0x40, 0xC2,
			0x02, 0x2C, 0x81, 0x06, 0x80, 0x9D, 0x42, 0xAC, 0x41, 0x27, 0x40,
			0x1F, 0x41, 0x01, 0x80, 0xAB, 0x00, 0x00, 0x80, 0x9D, 0x40, 0xCB,
			0x22, 0x90, 0x42, 0x9C, 0x41, 0xD0, 0x22, 0xAC, 0x41, 0x25, 0x22,
			0x16, 0x42, 0xAC, 0x41, 0xFA, 0x21, 0xFE, 0x41, 0xFA, 0x40, 0xA1,
			0x41, 0x01, 0x41, 0xDD, 0x00, 0xA2, 0x42, 0xC7, 0x02 };
	EVE_sleep(1000);

	EVE_Hal_wr8(phost, REG_CPURESET, 2);
	EVE_Hal_wrMem(phost, RAM_JTBOOT, touch_capcs_815, sizeof(touch_capcs_815));
	EVE_Hal_wr8(phost, REG_CPURESET, 0);
#endif
}

/**
 * Gpu_Init
 * EVE initialzation
 */
void Gpu_Init(EVE_HalContext* phost) {
	EVE_CHIPID_T chipId;
	size_t deviceIdx;

	EVE_HalParameters params;

#if defined(BT8XXEMU_PLATFORM)
	BT8XXEMU_EmulatorParameters emulatorParams;
#if defined(EVE_FLASH_AVAILABLE)
	BT8XXEMU_FlashParameters flashParams;
#endif
#endif

	EVE_Hal_initialize();

#ifdef EVE_MULTI_TARGET
	EVE_Util_selectDeviceInteractive(&chipId, &deviceIdx);
#else
	chipId = EVE_SUPPORT_CHIPID;
	deviceIdx = -1;
#endif

	EVE_Hal_defaultsEx(&params, deviceIdx);
	params.CbCmdWait = cbCmdWait;

#ifdef BT8XXEMU_PLATFORM
	EVE_Util_emulatorDefaults(&params, &emulatorParams, chipId);
#if defined(EVE_FLASH_AVAILABLE)
	EVE_Util_emulatorFlashDefaults(&params, &emulatorParams, &flashParams, L"__Flash.bin");
#endif
#endif

	EVE_Hal_open(phost, &params);

#ifdef EVE_MULTI_TARGET
	EVE_Util_bootupConfigInteractive(phost, EVE_DISPLAY_DEFAULT);
#else
	EVE_Util_bootupConfig(phost);
#endif

#ifdef DISPLAY_RESOLUTION_WXGA
	EVE_Hal_wr8(phost, REG_ADAPTIVE_FRAMERATE, 0);
	EVE_Hal_wr8(phost, REG_CPURESET, 2);
	EVE_Hal_wr16(phost, REG_TOUCH_CONFIG, 0x05D0);	//for Goodix touch panel
	EVE_Hal_wr8(phost, REG_CPURESET, 0);
	EVE_sleep(300);
#endif

#if defined(BT817_ENABLE) || defined(BT818_ENABLE)
	/// Enable capacity touch
	Init_CapacitiveTouch(phost);

	/// set API level to BT817
	EVE_CoCmd_apiLevel(phost, 2);
	EVE_Cmd_waitFlush(phost);
	printf("Set APILEVEL to BT817/8 (2)\n");
#else
	printf("Set APILEVEL to default (1)\n");
#endif

#if defined(FT900_PLATFORM) || defined(FT93X_PLATFORM)
	EVE_Util_loadSdCard(phost);
#endif

	// Precision control
	Setup_Precision(4); // Default vertext format = 4
}

void Gpu_Release(EVE_HalContext* phost) {
	EVE_Hal_close(phost);
	EVE_Hal_release();
}

/**
 *  Get_SystemClock
 * 	Get system frequency in Hz
 */
uint32_t Get_SystemClock(EVE_HalContext* phost) {
	EVE_Hal_rd32(phost, REG_CLOCK); // warm up

	uint32_t c0 = EVE_Hal_rd32(phost, REG_CLOCK);
	uint32_t c1 = EVE_Hal_rd32(phost, REG_CLOCK);

	uint32_t overhead = c1 - c0;

	c0 = EVE_Hal_rd32(phost, REG_CLOCK);
	EVE_sleep(1000);
	c1 = EVE_Hal_rd32(phost, REG_CLOCK);

	uint32_t freq = (uint32_t) round((c1 - c0) - overhead);

	return freq;
}

uint32_t Draw_Point(EVE_HalContext* phost, uint32_t Rx, uint32_t Ry, uint32_t R) {
	EVE_Cmd_wr32(phost, POINT_SIZE(VP(R)));
	EVE_Cmd_wr32(phost, BEGIN(POINTS));
	EVE_Cmd_wr32(phost, VERTEX2F(VP(Rx), VP(Ry)));
	return 1;
}

uint32_t Draw_Image(EVE_HalContext* phost, const char* filePath,
		uint32_t format) {
#if defined(BT817_ENABLE) || defined(BT818_ENABLE)
	Gpu_Hal_LoadImageToMemory(phost, filePath, RAM_G, LOADIMAGE);
	uint32_t ptr = 0;
	uint32_t w;
	uint32_t h;
	EVE_CoCmd_getProps(phost, &ptr, &w, &h);
	Display_End(phost);

	EVE_CoCmd_dlStart(phost);
	EVE_Cmd_wr32(phost, CLEAR(1, 1, 1));
	EVE_Cmd_wr32(phost, COLOR_RGB(255, 255, 255));
	EVE_Cmd_wr32(phost, COLOR_RGB(255, 255, 255));

	EVE_Cmd_waitFlush(phost);
	EVE_CoCmd_setBitmap(phost, RAM_G, (uint16_t) format, (uint16_t) w,
			(uint16_t) h);

	//Start drawing bitmap
	EVE_Cmd_wr32(phost, BEGIN(BITMAPS));
	EVE_Cmd_wr32(phost, VERTEX2II(0, 0, 0, 0));
	EVE_Cmd_wr32(phost, END());
	EVE_Cmd_wr32(phost, RESTORE_CONTEXT());
	EVE_Cmd_wr32(phost, DISPLAY());
	EVE_CoCmd_swap(phost);
	EVE_Cmd_waitFlush(phost);
#endif
	return 1;
}

void Calibration_Restore(EVE_HalContext* phost) {
	EVE_Hal_wr32(phost, REG_TOUCH_TRANSFORM_A, a);
	EVE_Hal_wr32(phost, REG_TOUCH_TRANSFORM_B, b);
	EVE_Hal_wr32(phost, REG_TOUCH_TRANSFORM_C, c);
	EVE_Hal_wr32(phost, REG_TOUCH_TRANSFORM_D, d);
	EVE_Hal_wr32(phost, REG_TOUCH_TRANSFORM_E, e);
	EVE_Hal_wr32(phost, REG_TOUCH_TRANSFORM_F, f);
}

void Calibration_Save(EVE_HalContext* phost) {
	a = EVE_Hal_rd32(phost, REG_TOUCH_TRANSFORM_A);
	b = EVE_Hal_rd32(phost, REG_TOUCH_TRANSFORM_B);
	c = EVE_Hal_rd32(phost, REG_TOUCH_TRANSFORM_C);
	d = EVE_Hal_rd32(phost, REG_TOUCH_TRANSFORM_D);
	e = EVE_Hal_rd32(phost, REG_TOUCH_TRANSFORM_E);
	f = EVE_Hal_rd32(phost, REG_TOUCH_TRANSFORM_F);
}

void Display_Start(EVE_HalContext* phost) {
	EVE_CoCmd_dlStart(phost);
	EVE_Cmd_wr32(phost, CLEAR_COLOR_RGB(255, 255, 255));
	EVE_Cmd_wr32(phost, CLEAR(1, 1, 1));
	EVE_Cmd_wr32(phost, COLOR_RGB(255, 255, 255));
	EVE_Cmd_wr32(phost, VERTEX_FORMAT(VertextFormat));
}

void Display_End(EVE_HalContext* phost) {
	EVE_Cmd_wr32(phost, DISPLAY());
	EVE_CoCmd_swap(phost);
	EVE_Cmd_waitFlush(phost);
}

static void Gpu_Text(EVE_HalContext* phost, const char8_t* str) {
	uint16_t font = 0;

	if (DispWidth == 480) {
		font = 28;
	} else if (DispWidth == 800) {
		font = 30;
	} else {
		font = 27;
	}

	Display_Start(phost);
	EVE_Cmd_wr32(phost, COLOR_RGB(0, 0, 0));
	EVE_CoCmd_fillWidth(phost, DispWidth);
	EVE_CoCmd_text(phost, (uint16_t) (DispWidth / 2),
			(uint16_t) (DispHeight / 2), font, OPT_CENTERX | OPT_FILL, str);
	Display_End(phost);
}

void Draw_Text(EVE_HalContext* phost, const char8_t* str) {
	Gpu_Text(phost, str);
	EVE_sleep(2000);
}

void Draw_Text2(EVE_HalContext* phost, const char8_t* str, int ms) {
	Gpu_Text(phost, str);
	EVE_sleep(ms);
}

void Play_MuteSound(EVE_HalContext* phost) {
	EVE_Hal_wr16(phost, REG_SOUND, 0x0060);
	EVE_Hal_wr8(phost, REG_PLAY, 0x01);
}

void Get_VC1Dump(EVE_HalContext* phost, const char* filename) {
#if defined(MSVC_PLATFORM) || defined(BT8XXEMU_PLATFORM)
#pragma warning(push)
#pragma warning(disable : 4996)
	FILE* vc1dump = fopen(filename, "wb");
#pragma warning(pop)

	if (!vc1dump) {
		APP_ERR("Cannot open file %s", filename);
		return;
	}

	const uint32_t version = 110;
	const uint32_t w = DispWidth;
	const uint32_t h = DispHeight;
	const uint32_t macro0 = 0;
	const uint32_t macro1 = 0;
	const uint32_t CRC_IMAGE = 0;

	fwrite(&version, 4, 1, vc1dump);
	fwrite(&w, 4, 1, vc1dump);
	fwrite(&h, 4, 1, vc1dump);
	fwrite(&macro0, 4, 1, vc1dump);
	fwrite(&macro1, 4, 1, vc1dump);
	fwrite(&CRC_IMAGE, 4, 1, vc1dump);

	uint8_t* buffer = malloc(RAM_G_SIZE);
	if (!buffer) {
		APP_ERR("Malloc failed");
		fclose(vc1dump);
		return;
	}

	memset(buffer, 0, RAM_G_SIZE);
	EVE_Hal_rdMem(phost, buffer, RAM_G, RAM_G_SIZE);
	fwrite(buffer, 1, RAM_G_SIZE, vc1dump);

	memset(buffer, 0, RAM_G_SIZE);
	EVE_Hal_rdMem(phost, buffer, RAM_DL, EVE_DL_SIZE);
	fwrite(buffer, 1, EVE_DL_SIZE, vc1dump);

	fclose(vc1dump);
	free(buffer);
#endif
}

void Play_Sound(EVE_HalContext* phost, uint8_t sound, uint8_t vol, uint8_t midi) {
	uint16_t val = (uint16_t) ((midi << 8) | sound);
	EVE_Hal_wr8(phost, REG_VOL_SOUND, vol);
	EVE_Hal_wr16(phost, REG_SOUND, val);
	EVE_Hal_wr8(phost, REG_PLAY, 1);
}

uint8_t isSDcardDetected() {
#if defined(MSVC_PLATFORM) || defined(BT8XXEMU_PLATFORM)
	return true;
#elif defined(FT9XX_PLATFORM)
	return sdhost_card_detect() == SDHOST_CARD_INSERTED;
#else
	return true;
#endif
}

void hintScreen(EVE_HalContext* phost, const uint8_t* msg) {
	Draw_Text(phost, msg);
}

void Flash_Init(EVE_HalContext* phost, const uint8_t *filePath,
		const uint8_t *fileName) {
	EVE_Util_loadSdCard(phost);
#if !defined(BT8XXEMU_PLATFORM) && defined(EVE_FLASH_AVAILABLE)
	/// if SD card is NOT detected, proceeds to boot up with a hint screen:
	if (!isSDcardDetected()) {
		hintScreen(phost,
				"Program the correct flash image to ensure EvChargePoint boots up successfully");
		return;
	} else {
		/// if SD card is detected, show a dialog on the screen with two options: Yes or No?
		if (!Show_Diaglog_YesNo(phost, "Flash programming",
				"Program the flash with the file in SD card?")) {
			/// If No, proceeds to boot up
			return;
		}

		/// If YES, Program the flash with the file in SD card
		int sent = Ftf_Write_File_To_Flash_With_Progressbar(phost, filePath,
				fileName, 0);

		/// If fail to program flash, reset application
		if (0 >= sent) {
			uint8_t count = 5;
			uint8_t msg[1000];
			while (count) {
#if defined(FT9XX_PLATFORM) || defined(EVE_PLATFORM_RP2040)
				snprintf(msg, 1000, "Error: Cannot open file: %s, reset in %us",
						filePath, count);
#else
				snprintf(msg, 1000, "Error: Cannot open file: %s, exit in %u s",
					fileName, count);
#endif
				Show_Diaglog_Info(phost, msg);
				EVE_sleep(1000);
				count--;
			}
			exit(0);
		}
	}
#endif
}

void Show_Diaglog_Info(EVE_HalContext* phost, const uint8_t* msg) {
	uint8_t ret = INPUT_NO;
	const uint32_t tag_y = 1;
	const uint32_t tag_n = 2;

	const uint16_t border = 2; // pixel
	const uint16_t base_w = 800;
	const uint16_t base_h = 600;
	uint16_t w = 400;
	uint16_t h = 200;
	uint16_t x = (base_w - w) / 2;
	uint16_t y = (base_h - h) / 2;
	uint8_t htop = 50;
	uint8_t hbottom = 50;
	uint8_t font = 20;

	uint16_t btn_h = 40;
	uint16_t btn_w = 100;

	uint32_t ratio = base_w * 100 / DispWidth;

	if (ratio != 100) {
		w = w * 100 / ratio;
		h = h * 100 / ratio;
		btn_w = btn_w * 100 / ratio;
		btn_h = btn_h * 100 / ratio;
		x = (DispWidth - w) / 2;
		y = (DispHeight - h) / 2;
		htop = htop * 100 / ratio;
		hbottom = hbottom * 100 / ratio;

		ratio += (100 - ratio) / 2;
		font = font * 100 / ratio;
		if (font > 31)
			font = 31;
		if (font < 16)
			font = 16;
		if (font == 17 || font == 19)
			font = 18;
	}

	Display_Start(phost);

	/// fade the whole LCD
	EVE_Cmd_wr32(phost, COLOR_RGB(0x3F, 0x3F, 0x3F));
	EVE_Cmd_wr32(phost, BEGIN(RECTS));
	EVE_Cmd_wr32(phost, VERTEX2F(0, 0));
	EVE_Cmd_wr32(phost, VERTEX2F(VP(DispWidth), VP(DispHeight)));

	/// diag border
	EVE_Cmd_wr32(phost, COLOR_RGB(0xE1, 0xE1, 0xE1));
	EVE_Cmd_wr32(phost, BEGIN(RECTS));
	EVE_Cmd_wr32(phost, VERTEX2F(VP(x), VP(y)));
	EVE_Cmd_wr32(phost, VERTEX2F(VP(x + w), VP(y + h)));

	/// center part
	EVE_Cmd_wr32(phost, COLOR_RGB(0xFF, 0xFF, 0xFF));
	EVE_Cmd_wr32(phost, BEGIN(RECTS));
	EVE_Cmd_wr32(phost, VERTEX2F(VP(x + border), VP(y + border)));
	EVE_Cmd_wr32(phost, VERTEX2F(VP(x + w - border), VP(y + h - border)));

	/// top part
	EVE_Cmd_wr32(phost, COLOR_RGB(0xF3, 0xF3, 0xF3));
	EVE_Cmd_wr32(phost, BEGIN(RECTS));
	EVE_Cmd_wr32(phost, VERTEX2F(VP(x + border), VP(y + border)));
	EVE_Cmd_wr32(phost, VERTEX2F(VP(x + w - border), VP(y + htop)));

	/// bottom part
	EVE_Cmd_wr32(phost, COLOR_RGB(0xF3, 0xF3, 0xF3));
	EVE_Cmd_wr32(phost, BEGIN(RECTS));
	EVE_Cmd_wr32(phost, VERTEX2F(VP(x + border), VP(y + h - hbottom + border)));
	EVE_Cmd_wr32(phost, VERTEX2F(VP(x + w - border), VP(y + h - border)));

	font = font * 8 / 10;
	if (font < 16)
		font = 16;
	if (font == 17 || font == 19)
		font = 18;
	EVE_Cmd_wr32(phost, COLOR_RGB(0x78, 0x78, 0x78));
	EVE_CoCmd_text(phost, x + border + 30, y + h / 2 - 20, font, 0, msg);

	Display_End(phost);

}

uint8_t Show_Diaglog_YesNo(EVE_HalContext* phost, const uint8_t* title,
		const uint8_t* msg) {
	uint8_t ret = INPUT_NO;
	const uint32_t tag_y = 1;
	const uint32_t tag_n = 2;

	const uint16_t border = 2; // pixel
	const uint16_t base_w = 800;
	const uint16_t base_h = 600;
	uint16_t w = 400;
	uint16_t h = 200;
	uint16_t x = (base_w - w) / 2;
	uint16_t y = (base_h - h) / 2;
	uint8_t htop = 50;
	uint8_t hbottom = 50;
	uint8_t font = 20;

	uint16_t btn_h = 30;
	uint16_t btn_w = 80;

	uint32_t ratio = base_w * 100 / DispWidth;

	if (ratio != 100) {
		w = w * 100 / ratio;
		h = h * 100 / ratio;
		btn_w = btn_w * 100 / ratio;
		btn_h = btn_h * 100 / ratio;
		x = (DispWidth - w) / 2;
		y = (DispHeight - h) / 2;
		htop = htop * 100 / ratio;
		hbottom = hbottom * 100 / ratio;

		ratio += (100 - ratio) / 2;
		font = font * 100 / ratio;
		if (font > 31)
			font = 31;
		if (font < 16)
			font = 16;
		if (font == 17 || font == 19)
			font = 18;
	}

	do {
		Display_Start(phost);

		/// fade the whole LCD
		EVE_Cmd_wr32(phost, COLOR_RGB(0x3F, 0x3F, 0x3F));
		EVE_Cmd_wr32(phost, BEGIN(RECTS));
		EVE_Cmd_wr32(phost, VERTEX2F(0, 0));
		EVE_Cmd_wr32(phost, VERTEX2F(VP(DispWidth), VP(DispHeight)));

		/// diag border
		EVE_Cmd_wr32(phost, COLOR_RGB(0xE1, 0xE1, 0xE1));
		EVE_Cmd_wr32(phost, BEGIN(RECTS));
		EVE_Cmd_wr32(phost, VERTEX2F(VP(x), VP(y)));
		EVE_Cmd_wr32(phost, VERTEX2F(VP(x + w), VP(y + h)));

		/// center part
		EVE_Cmd_wr32(phost, COLOR_RGB(0xFF, 0xFF, 0xFF));
		EVE_Cmd_wr32(phost, BEGIN(RECTS));
		EVE_Cmd_wr32(phost, VERTEX2F(VP(x + border), VP(y + border)));
		EVE_Cmd_wr32(phost, VERTEX2F(VP(x + w - border), VP(y + h - border)));

		/// top part
		EVE_Cmd_wr32(phost, COLOR_RGB(0x46, 0x50, 0x52));
		EVE_Cmd_wr32(phost, BEGIN(RECTS));
		EVE_Cmd_wr32(phost, VERTEX2F(VP(x + border), VP(y + border)));
		EVE_Cmd_wr32(phost, VERTEX2F(VP(x + w - border), VP(y + htop)));

		/// bottom part
		EVE_Cmd_wr32(phost, COLOR_RGB(0xF3, 0xF3, 0xF3));
		EVE_Cmd_wr32(phost, BEGIN(RECTS));
		EVE_Cmd_wr32(phost,
				VERTEX2F(VP(x + border), VP(y + h - hbottom + border)));
		EVE_Cmd_wr32(phost, VERTEX2F(VP(x + w - border), VP(y + h - border)));

		/// diag message
		EVE_Cmd_wr32(phost, COLOR_RGB(0xFF, 0xFF, 0xFF));
		EVE_CoCmd_text(phost, x + border + 10, y + border + 10, font, 0, title);

		uint32_t font2 = font * 8 / 10;
		if (font2 < 16)
			font2 = 16;
		if (font2 == 17 || font2 == 19)
			font2 = 18;
		EVE_Cmd_wr32(phost, COLOR_RGB(0x78, 0x78, 0x78));
		EVE_CoCmd_fillWidth(phost, w);
		EVE_CoCmd_text(phost, x + border + 30, y + h / 2 - 20, font2, OPT_FILL, msg);

		/// diag button yes/no
		EVE_Cmd_wr32(phost, COLOR_RGB(0xFF, 0xFF, 0xFF));
		const uint16_t btn_margin = 25;
		EVE_Cmd_wr32(phost, TAG(tag_y));
		EVE_CoCmd_button(phost, x + w / 2 - btn_w - btn_margin,
				y + h - hbottom + border + (hbottom - btn_h) / 2, btn_w, btn_h,
				font, 0, "Yes");

		EVE_Cmd_wr32(phost, TAG(tag_n));
		EVE_CoCmd_button(phost, x + w / 2 + btn_margin,
				y + h - hbottom + border + (hbottom - btn_h) / 2, btn_w, btn_h,
				font, 0, "No");

		Display_End(phost);

		Gesture_Renew(phost);
		if (Gesture_Get()->tagReleased == tag_y) {
			return true;
		} else if (Gesture_Get()->tagReleased == tag_n) {
			return false;
		}
	} while (true);

	return false;
}

